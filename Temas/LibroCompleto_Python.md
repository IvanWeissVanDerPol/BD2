# Bases de Datos Avanzadas - Libro Completo

Este libro re√∫ne todos los temas relacionados con Bases de Datos Avanzadas en un solo lugar.

## Tabla de Contenidos

1. [√çndices](#1-√≠ndices)
2. [Organizaci√≥n F√≠sica de Archivos](#2-organizaci√≥n-f√≠sica-de-archivos)
3. [Medidas de Rendimiento de Discos](#3-medidas-de-rendimiento-de-discos)
4. [Niveles RAID](#4-niveles-raid)
5. [√Årboles B y B+](#5-√°rboles-b-y-b)
6. [Algoritmos de B√∫squeda](#6-algoritmos-de-b√∫squeda)
7. [Procesamiento de Consultas](#7-procesamiento-de-consultas)
8. [Modelado Multidimensional](#8-modelado-multidimensional)
9. [Transacciones (ACID)](#9-transacciones-acid)
10. [Concurrencia](#10-concurrencia)
11. [Protocolos Distribuidos](#11-protocolos-distribuidos)
12. [Almacenamiento Distribuido](#12-almacenamiento-distribuido)
13. [Optimizaci√≥n de Consultas](#13-optimizaci√≥n-de-consultas)
14. [Normalizaci√≥n y Dependencias Funcionales](#14-normalizaci√≥n-y-dependencias-funcionales)
15. [Modelado ER y SQL](#15-modelado-er-y-sql)


## 1. Indices



## üîç **¬øQu√© es un √çndice?**

Un **√≠ndice** en bases de datos es una estructura auxiliar que facilita la recuperaci√≥n eficiente de registros espec√≠ficos, reduciendo significativamente el tiempo de consulta. Funciona de manera similar al √≠ndice al final de un libro: permite localizar informaci√≥n r√°pidamente sin revisar todo el contenido.

Un **archivo √≠ndice** es un archivo f√≠sico separado que almacena referencias a las filas del archivo principal de datos seg√∫n el valor de la columna indexada.

### üìå **Tipos principales de √≠ndices estudiados:**
1. **√çndice ordenado** (basado en √°rboles B y B+).
2. **√çndice hash**.
3. **√çndice bitmap**.

---

## üìó **Tipos de √çndices seg√∫n sus consultas apropiadas**

| Tipo √≠ndice | Ideal para consultas |
|-------------|----------------------|
| Ordenado    | Rangos (ej. fechas, intervalos num√©ricos) |
| Hash        | Consultas exactas (condiciones de igualdad) |
| Bitmap      | Consultas m√∫ltiples simult√°neas (muchas condiciones sobre columnas booleanas o categ√≥ricas) |

---

## üìö **Tipos de √çndices seg√∫n su Organizaci√≥n F√≠sica**

### 1. **√çndice Ordenado (√Årbol B/B+)**
- Almacena valores ordenados jer√°rquicamente, permitiendo b√∫squedas r√°pidas y eficientes.
- Aplicaci√≥n ideal: consultas con rangos, valores cercanos.

### 2. **√çndice Hash**
- Usa una funci√≥n de hash para determinar la ubicaci√≥n f√≠sica de un dato.
- Aplicaci√≥n ideal: b√∫squedas puntuales exactas.

### 3. **√çndice Bitmap**
- Cada valor √∫nico tiene un mapa de bits asociado, √∫til en columnas con pocos valores √∫nicos.
- Aplicaci√≥n ideal: m√∫ltiples condiciones simult√°neas.

---

## üìà **Costos Asint√≥ticos de Algoritmos de B√∫squeda**

| Algoritmo               | Costo Asint√≥tico (promedio) |
|-------------------------|-----------------------------|
| (a) B√∫squeda lineal     | O(n)                        |
| (b) B√∫squeda binaria    | O(log n)                    |
| (c) √çndice primario (B+) | O(log n)                   |
| (d) √çndice secundario   | O(log n)                    |

---

## üìå **Condiciones f√≠sicas para usar algoritmos (en igualdad):**

| Algoritmo           | Condici√≥n f√≠sica ideal                  |
|---------------------|----------------------------------------|
| B√∫squeda Lineal     | No existe √≠ndice. Tabla peque√±a.        |
| B√∫squeda Binaria    | Tabla ordenada secuencialmente sin √≠ndices disponibles.|
| √çndice Primario (B+)| Existe √≠ndice sobre clave primaria.     |
| √çndice Secundario   | Existe √≠ndice sobre atributo no clave.  |

---

## üìä **Gr√°fico ilustrativo (Ejemplo √çndice B+):**

```plaintext
                   [20, 40]
                  /    |    \
         [5,10,15] [25,30,35] [45,50,55]
```

- **B√∫squeda**: Recorre √°rbol desde ra√≠z hacia hojas r√°pidamente.

---

## üß© **Ejercicios Resueltos**

### üõ†Ô∏è **Tema 6: Construcci√≥n √çndice Hash (Asociaci√≥n Extensible)**

La asociaci√≥n extensible es una t√©cnica de hash din√°mico que permite expandir el espacio de almacenamiento conforme crece la base de datos.

**Ejemplo:**

- Funci√≥n hash simple: `h(x) = x mod 4`
- Datos iniciales: `4, 8, 5, 7, 12, 15`

| Caj√≥n (bucket) | Valores almacenados |
|----------------|---------------------|
| 0              | 4, 8, 12            |
| 1              | 5                   |
| 2              |                    |
| 3              | 7, 15               |

Cuando un caj√≥n excede capacidad, se duplica el √≠ndice aumentando el n√∫mero de bits y re-distribuyendo valores.

---

### üõ†Ô∏è **Tema 10: √çndice B+ e √çndice Hash Est√°tico**

#### üîπ **Construcci√≥n √çndice B+ (ejemplo sencillo):**

Datos: `[10,20,30,40,50,60,70,80]`, 4 punteros por nodo.

```plaintext
         [40]
      /        \
  [10,20,30]  [50,60,70,80]
```

- **Clasificaci√≥n:** Primario (si √≠ndice est√° sobre clave primaria).

#### üîπ **Construcci√≥n √çndice Hash est√°tico:**

Datos: `[21,32,43,54]`, funci√≥n hash `h(x) = x mod 4`

| Caj√≥n | Datos     |
|-------|-----------|
| 0     | 32        |
| 1     | 21        |
| 2     | 54        |
| 3     | 43        |

- **Clasificaci√≥n:** Secundario (generalmente √≠ndices hash son secundarios, ya que suelen aplicarse a atributos no clave para b√∫squedas exactas).

---

## ‚úÖ **Ejercicios planteados:**

### **Ejercicio 1: ¬øQu√© es un √≠ndice y archivo √≠ndice?**
- **√çndice:** Estructura auxiliar que acelera la recuperaci√≥n de datos.
- **Archivo √≠ndice:** Archivo f√≠sico separado que contiene referencias a registros seg√∫n columna indexada.

**Tres tipos de √≠ndices estudiados:**
- √çndice Ordenado (√Årbol B+).
- √çndice Hash.
- √çndice Bitmap.

---

### **Ejercicio 2: √çndices apropiados seg√∫n consulta:**
- (a) **Ordenado:** Rangos, intervalos. (Ej: Fecha de nacimiento entre 1990-2000).
- (b) **Hash:** Igualdad exacta. (Ej: CI = 123456).
- (c) **Bitmap:** M√∫ltiples condiciones simult√°neas. (Ej: G√©nero=Femenino AND Ciudad=Asunci√≥n).

---

### **Ejercicio 3: Organizaci√≥n f√≠sica y aplicaci√≥n:**
- **B+ (Ordenado):** Consultas rango, ordenaci√≥n r√°pida.
- **Hash:** Igualdad exacta r√°pida.
- **Bitmap:** Consultas anal√≠ticas con m√∫ltiples condiciones categ√≥ricas.

---

### **Ejercicio 4: Costos asint√≥ticos explicados antes.**
- (a) Lineal: `O(n)`
- (b) Binaria: `O(log n)`
- (c) Primario: `O(log n)`
- (d) Secundario: `O(log n)`

---

### **Ejercicio 5: Condiciones f√≠sicas explicadas antes.**

- **Lineal:** Sin √≠ndice, tabla peque√±a.
- **Binaria:** Tabla ordenada sin √≠ndice.
- **Primario:** √çndice clave primaria disponible.
- **Secundario:** √çndice atributo no clave disponible.

---

### üìå **Resumen Visual del uso de √≠ndices seg√∫n tipo de consulta:**
```plaintext
Consultas de rango  ‚Üí √çndice Ordenado (B+)
Consultas exactas   ‚Üí √çndice Hash
Consultas complejas ‚Üí √çndice Bitmap
```

---

## üìù **Conclusi√≥n**

- **√çndices** aceleran consultas significativamente.
- Cada tipo es ideal seg√∫n tipo de consulta y estructura de datos.
- Importante evaluar costo-beneficio al elegir √≠ndice.



## 2. Organizacion Fisica Archivos



# üìÇ **Organizaci√≥n F√≠sica de Archivos**

La **organizaci√≥n f√≠sica de archivos** hace referencia a c√≥mo se almacenan los registros en los archivos f√≠sicos de un Sistema Gestor de Bases de Datos (SGBD). Elegir la estructura adecuada afecta considerablemente el rendimiento, especialmente en consultas e inserciones.

---

## üìë **Formas de Organizaci√≥n F√≠sica**

Existen principalmente cuatro formas de organizaci√≥n f√≠sica:

### **1. Heap (Mont√≥n):**
- Los registros son almacenados en cualquier espacio libre disponible.
- **Ventaja:** Inserci√≥n muy r√°pida.
- **Desventaja:** Consultas lentas (requiere escaneo completo).

**Ejemplo:**  
Agregar un nuevo cliente al archivo de clientes sin preocuparse de d√≥nde queda ubicado exactamente.

---

### **2. Secuencial (Ordenado):**
- Registros almacenados consecutivamente en orden seg√∫n una clave.
- **Ventaja:** Consultas por rango muy eficientes.
- **Desventaja:** Inserciones lentas, requieren reorganizaci√≥n peri√≥dica.

**Ejemplo:**  
Historial de transacciones ordenado por fecha.

---

### **3. Hash:**
- Ubicaci√≥n de registros determinada por una funci√≥n hash aplicada sobre la clave.
- **Ventaja:** B√∫squeda puntual extremadamente r√°pida.
- **Desventaja:** Mal rendimiento en consultas por rango.

**Ejemplo:**  
Buscar datos exactos como DNI o n√∫mero de tel√©fono.

---

### **4. Agrupaci√≥n (Cluster):**
- Almacena juntos registros relacionados o que se consultan con frecuencia.
- **Ventaja:** Consultas comunes aceleradas.
- **Desventaja:** Actualizaciones m√°s lentas si afectan las columnas agrupadas.

**Ejemplo:**  
Datos de un cliente y todas sus facturas en bloques cercanos.

---

## üìã **Organizaci√≥n de registros en archivos (resumen en t√©rminos simples):**
- **Heap:** Cualquier lugar libre (desordenado, r√°pido inserci√≥n).
- **Secuencial:** Ordenado en funci√≥n de una clave.
- **Hash:** Ubicaci√≥n mediante c√°lculo hash.
- **Cluster:** Agrupaci√≥n l√≥gica de datos relacionados.

---

## üóÇÔ∏è **Formas de organizaci√≥n para implementar tablas/datos (simplificado):**
- Para datos que cambian mucho: **Heap**.
- Para consultas frecuentes de rangos: **Secuencial**.
- Para b√∫squedas exactas r√°pidas: **Hash**.
- Para consultas relacionadas frecuentes: **Cluster**.

---

## üìå **Tema 9: Estructura f√≠sica de bloques (P√°ginas por ranuras)**

La organizaci√≥n por p√°ginas y ranuras (slot-based pages) se implementa dividiendo cada bloque f√≠sico del archivo en "ranuras" que almacenan registros individuales. Esto facilita inserciones, eliminaciones y modificaciones con m√≠nima fragmentaci√≥n.

### üîπ **Implementaci√≥n:**
Cada p√°gina se divide en dos partes:
- **Cabecera:** Contiene un directorio con punteros (slots) hacia los registros.
- **Cuerpo de datos:** Registros almacenados secuencialmente (no necesariamente contiguos).

Cada registro se accede mediante la referencia en la ranura, permitiendo eliminar y reutilizar espacios f√°cilmente.

### Ejemplo visual (gr√°fico):

```
P√°gina F√≠sica (Bloque)
+-------------------------+
| Cabecera de ranuras     |
|-------------------------|
| Ranura 1 -> Registro A  |
| Ranura 2 -> Registro B  |
| Ranura 3 -> [libre]     |
| Ranura 4 -> Registro C  |
|-------------------------|
| Cuerpo de registros     |
| [Registro A]            |
| [Registro B]            |
| [espacio libre]         |
| [Registro C]            |
+-------------------------+
```

- Al borrar un registro, simplemente se marca la ranura como disponible.
- Al insertar, se reutilizan ranuras vac√≠as.

---

## üìä **Gr√°fica Comparativa de rendimiento por tipo de organizaci√≥n:**

```plaintext
Rendimiento (menor tiempo es mejor)

Consulta exacta:
Hash          [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†]
Secuencial    [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°]
Heap          [‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°]
Cluster       [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°]

Consulta rango:
Secuencial    [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†]
Cluster       [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°]
Heap          [‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°]
Hash          [‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°]

Inserci√≥n r√°pida:
Heap          [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†]
Hash          [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°]
Cluster       [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°]
Secuencial    [‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°]
```

---

## üìù **Respuestas detalladas a los ejercicios propuestos:**

### üîπ **1. Explicaci√≥n de las formas de organizaci√≥n f√≠sica en SGBD:**

- **Heap:** No ordenado, r√°pido insertar, lento consultar.
- **Secuencial:** Ordenado por clave, r√°pido para rangos, lento insertar.
- **Hash:** Distribuci√≥n por funci√≥n hash, b√∫squedas exactas r√°pidas.
- **Cluster:** Agrupaci√≥n l√≥gica, mejora consultas frecuentes relacionadas.

---

### üîπ **2. Formas resumidas de organizaci√≥n de registros (propios t√©rminos):**

- **Heap:** Registros en espacio disponible r√°pidamente.
- **Secuencial:** Registros siempre en orden espec√≠fico.
- **Hash:** Ubicaci√≥n seg√∫n c√°lculo matem√°tico (hash).
- **Cluster:** Registros relacionados almacenados cerca.

---

### üîπ **3. Formas apropiadas para implementaci√≥n pr√°ctica de tablas/datos:**

| Uso habitual               | Organizaci√≥n ideal |
|----------------------------|--------------------|
| Insertar muy frecuentemente| Heap               |
| Rangos frecuentes          | Secuencial         |
| Igualdad frecuente         | Hash               |
| Datos relacionados juntos  | Cluster            |

---

### üîπ **4. Detalle de la estructura de p√°ginas por ranuras (Tema 9):**

- Divide p√°gina en dos zonas: cabecera (ranuras) y cuerpo (registros).
- Usa directorio de ranuras con punteros hacia registros reales.
- Permite gesti√≥n eficiente de inserci√≥n/borrado con fragmentaci√≥n m√≠nima.

---

## ‚úÖ **Ejemplo pr√°ctico de p√°gina por ranuras:**

- Inserci√≥n:
  - Registro D entra en ranura 3 libre.

```
+-------------------------+
| Cabecera de ranuras     |
|-------------------------|
| Ranura 1 -> Registro A  |
| Ranura 2 -> Registro B  |
| Ranura 3 -> Registro D  |
| Ranura 4 -> Registro C  |
|-------------------------|
| Cuerpo de registros     |
| [Registro A]            |
| [Registro B]            |
| [Registro D]            |
| [Registro C]            |
+-------------------------+
```

- Eliminaci√≥n de registro B:
  - Ranura 2 queda libre, espacio disponible para inserci√≥n futura.

```
+-------------------------+
| Cabecera de ranuras     |
|-------------------------|
| Ranura 1 -> Registro A  |
| Ranura 2 -> [libre]     |
| Ranura 3 -> Registro D  |
| Ranura 4 -> Registro C  |
|-------------------------|
| Cuerpo de registros     |
| [Registro A]            |
| [espacio disponible]    |
| [Registro D]            |
| [Registro C]            |
+-------------------------+
```

---

## üìå **Conclusiones clave sobre Organizaci√≥n F√≠sica de Archivos:**
- Elegir estructura depende del patr√≥n de uso (insertar vs consultar).
- Heap es r√°pido para insertar; secuencial ideal para consultas por rango.
- Hash destaca en igualdad exacta; Cluster ideal para datos relacionados frecuentes.
- Estructura de p√°ginas por ranuras optimiza el almacenamiento y acceso f√≠sico.



## 3. Medidas Rendimiento Discos


# üíæ **Medidas de Rendimiento de Discos**

Al elegir discos magn√©ticos (HDD) para bases de datos, es esencial considerar ciertas medidas de rendimiento para garantizar eficiencia, rapidez y confiabilidad en el acceso a datos.

---

## üìè **Principales Medidas de Rendimiento**

### **1. Tiempo de acceso (Seek Time)**
- Tiempo necesario para mover la cabeza lectora hacia la pista deseada.
- **Medici√≥n habitual:** milisegundos (ms).
- **Ejemplo t√≠pico:** 3-15 ms.

### **2. Latencia rotacional (Rotational Latency)**
- Tiempo que tarda en girar el disco hasta que el sector correcto queda bajo la cabeza.
- Depende directamente de la velocidad de rotaci√≥n del disco (RPM).
- **Ejemplo:**  
  - 7200 RPM ‚Üí 4,16 ms promedio  
  - 10.000 RPM ‚Üí 3 ms promedio

### **3. Tasa de transferencia (Transfer Rate)**
- Cantidad de datos transferidos desde el disco hacia la memoria por unidad de tiempo.
- **Medici√≥n habitual:** MB/s o GB/s.
- **Ejemplo:**  
  - HDD t√≠pico: 100-200 MB/s  
  - SSD t√≠pico: 400-5000 MB/s

### **4. Tiempo medio entre fallos (Mean Time Between Failures - MTBF)**
- Tiempo promedio esperado antes de que el disco presente un fallo.
- **Medici√≥n habitual:** Horas (usualmente miles o millones de horas).
- **Ejemplo t√≠pico:** 1 mill√≥n de horas (114 a√±os aprox.); aunque es un promedio te√≥rico.

---

## üéØ **Medida m√°s determinante**

- En bases de datos, el **tiempo de acceso (seek time)** suele ser la medida m√°s cr√≠tica.
- Esto se debe a que las bases de datos suelen realizar muchas operaciones aleatorias peque√±as en lugar de grandes transferencias secuenciales.

---

## üõó **Algoritmo del Ascensor (Elevator Algorithm)**

Es un algoritmo utilizado para optimizar el movimiento del cabezal en discos magn√©ticos, minimizando el tiempo de acceso total.

### üîπ **Funcionamiento:**
- El cabezal se mueve en una direcci√≥n (por ejemplo, hacia afuera), atendiendo todas las solicitudes en esa direcci√≥n.
- Al alcanzar el extremo, cambia de direcci√≥n y atiende las solicitudes que quedaron pendientes hacia el otro lado.
- Simula el movimiento de un ascensor real en un edificio.

### üîπ **Ventaja:**
- Reduce considerablemente el movimiento del cabezal, mejorando la eficiencia.

---

## üìà **M√©tricas principales asociadas al rendimiento del disco:**

| M√©trica             | Explicaci√≥n breve                          |
|---------------------|--------------------------------------------|
| **Tiempo de acceso**| Tiempo de mover cabezal al lugar correcto. |
| **Latencia rotacional**| Tiempo en girar sector hasta el cabezal.|
| **Tasa transferencia** | Datos transferidos por unidad de tiempo. |
| **MTBF**            | Fiabilidad, vida √∫til antes de fallos.     |

---

## üìä **Gr√°fico Ilustrativo del Algoritmo del Ascensor:**

**Ejemplo pr√°ctico**:

Solicitudes a pistas: `40, 70, 35, 80, 20`

Pista actual del cabezal: `50`, Direcci√≥n inicial: hacia arriba (n√∫meros mayores)

```plaintext
Direcci√≥n inicial ‚Üí hacia arriba
20 ----- 35 ----- [40] ----- [50] ----- [70] ----- [80]
                         ‚Üë inicio aqu√≠

- Primero atiende: 70, 80
- Luego cambia direcci√≥n y atiende: 40, 35, 20
```

### Comparativa r√°pida:

| Sin algoritmo | Con algoritmo Ascensor |
|---------------|------------------------|
| 50‚Üí40‚Üí70‚Üí35‚Üí80‚Üí20 | 50‚Üí70‚Üí80‚Üí40‚Üí35‚Üí20 |
| Movimientos innecesarios grandes | Menos movimientos, optimizaci√≥n notable |

---

## üß© **Ejercicios Resueltos:**

### ‚úÖ **1. Explicaci√≥n detallada de medidas de rendimiento de discos magn√©ticos:**

| Medida             | Detalle y ejemplo t√≠pico |
|--------------------|--------------------------|
| **Tiempo de acceso** | Movimiento del cabezal (Ej: 8 ms promedio) |
| **Latencia rotacional**| Velocidad del giro hasta sector (Ej: 4 ms para 7200 RPM) |
| **Tasa transferencia** | Velocidad de datos (Ej: 150 MB/s) |
| **MTBF**            | Vida √∫til promedio (Ej: 1 mill√≥n horas) |

---

### ‚úÖ **2. ¬øCu√°l ser√≠a la m√°s determinante?**
- La m√°s determinante: **Tiempo de acceso**.
- Es cr√≠tica para consultas peque√±as y aleatorias frecuentes, habituales en SGBD.

---

### ‚úÖ **3. Algoritmo del Ascensor y sus principales m√©tricas:**
- **Explicaci√≥n breve:**  
  Atender solicitudes moviendo el cabezal en una direcci√≥n hasta terminar todas las solicitudes pendientes, luego cambiar de direcci√≥n.
  
- **Principales m√©tricas asociadas:**  
  - Reducci√≥n del **tiempo promedio de acceso**.
  - Reducci√≥n del desgaste mec√°nico por menos movimientos.

---

## üìå **Ejemplo num√©rico detallado del algoritmo del Ascensor:**

- Solicitudes: `[15, 10, 22, 4, 9, 30]`
- Posici√≥n inicial cabezal: `12`
- Direcci√≥n inicial: Hacia arriba (hacia n√∫meros mayores).

Gr√°fico ilustrativo del proceso:

```
Inicial: 12
Direcci√≥n ‚Üí arriba:
12 ‚Üí 15 ‚Üí 22 ‚Üí 30  [ascendente finalizado]

Cambio de direcci√≥n ‚Üê abajo:
30 ‚Üí 10 ‚Üí 9 ‚Üí 4    [descendente finalizado]

Orden √≥ptimo final: [12 ‚Üí 15 ‚Üí 22 ‚Üí 30 ‚Üí 10 ‚Üí 9 ‚Üí 4]
```

---

## üö¶ **Conclusi√≥n clave del tema:**
- Las medidas m√°s importantes son tiempo de acceso y latencia rotacional, cruciales para el rendimiento en bases de datos.
- El algoritmo del ascensor optimiza estos tiempos reduciendo movimientos innecesarios.



## 4. Niveles RAID


# üìÄ **Introducci√≥n a RAID**

**RAID (Redundant Array of Independent Disks)** es una tecnolog√≠a que combina m√∫ltiples discos f√≠sicos en una sola unidad l√≥gica para aumentar la **velocidades de acceso a datos**, proveer **redundancia** (seguridad ante fallos) o una combinaci√≥n de ambos.

---

## üìå **Principales Niveles RAID (0, 1 y 5)**

### 1. üîπ **RAID 0 (Stripe - Sin redundancia)**

- Divide datos en bloques distribuidos secuencialmente entre m√∫ltiples discos.
- **Ventajas:**  
  - Excelente rendimiento en velocidad de lectura/escritura.
  - Aprovecha al m√°ximo la capacidad total (sin redundancia).

- **Desventaja:**  
  - Alta vulnerabilidad; la falla de un solo disco implica p√©rdida total de los datos.

- **Uso t√≠pico:**  
  Edici√≥n de video/audio, gaming, aplicaciones que requieren altas velocidades.

**Ejemplo gr√°fico RAID 0 (dos discos):**

```
Disco 1: Bloque 1 - Bloque 3 - Bloque 5
Disco 2: Bloque 2 - Bloque 4 - Bloque 6
```

---

### 2. üîπ **RAID 1 (Mirroring - Redundancia exacta)**

- Duplica los datos exactamente en dos o m√°s discos (espejo exacto).
- **Ventajas:**  
  - Muy seguro, resistente a fallos (puede fallar un disco sin p√©rdida de informaci√≥n).
  - Alta disponibilidad.

- **Desventaja:**  
  - M√°s caro, capacidad √∫til reducida a la mitad.
  - Velocidad de escritura ligeramente inferior debido a la duplicaci√≥n.

- **Uso t√≠pico:**  
  Servidores de datos cr√≠ticos, bases de datos peque√±as donde la fiabilidad es primordial.

**Ejemplo gr√°fico RAID 1 (dos discos espejo):**

```
Disco 1: Bloque A - Bloque B - Bloque C
Disco 2: Bloque A - Bloque B - Bloque C (Copia exacta)
```

---

### 3. üîπ **RAID 5 (Paridad Distribuida - Equilibrio)**

- Distribuye los datos en m√∫ltiples discos, pero tambi√©n guarda informaci√≥n de paridad (para recuperaci√≥n de datos) de manera distribuida.
- **Ventajas:**  
  - Buen equilibrio rendimiento/seguridad.
  - Permite recuperaci√≥n ante falla de un solo disco.
  - Uso eficiente del espacio (solo un disco de capacidad se utiliza para paridad).

- **Desventaja:**  
  - Reconstrucci√≥n lenta en caso de fallo.
  - Complejidad mayor.

- **Uso t√≠pico:**  
  Servidores empresariales y bases de datos de tama√±o mediano/grande.

**Ejemplo gr√°fico RAID 5 (tres discos):**

```
Disco 1: Bloque 1 - Bloque 4 - Paridad (P3)
Disco 2: Bloque 2 - Paridad (P2) - Bloque 5
Disco 3: Paridad (P1) - Bloque 3 - Bloque 6
```

---

## üìå **Raz√≥n Principal para la Implementaci√≥n de RAID con Redundancia:**

La principal raz√≥n es **garantizar la disponibilidad y seguridad** de los datos ante fallos de discos f√≠sicos. RAID proporciona mecanismos autom√°ticos de recuperaci√≥n y tolerancia a fallos.

---

## üöÄ **Ventajas clave del almacenamiento RAID:**

### üîπ **En rendimiento:**
- Lecturas simult√°neas m√°s r√°pidas (RAID 0, 5).
- Mejora en velocidad al distribuir carga en varios discos.

### üîπ **En fiabilidad:**
- Seguridad de datos mediante redundancia (RAID 1 y RAID 5).
- Recuperaci√≥n r√°pida en fallos parciales (RAID 1).
- Tolerancia efectiva a fallos sin interrupci√≥n (RAID 1, RAID 5).

---

## üìä **Gr√°fico comparativo r√°pido de niveles RAID:**

| Caracter√≠stica | RAID 0             | RAID 1               | RAID 5             |
|----------------|--------------------|----------------------|--------------------|
| Rendimiento    | ‚úÖ Muy alto        | ‚ö†Ô∏è Moderado-Alto     | ‚úÖ Alto            |
| Redundancia    | ‚ùå No              | ‚úÖ Completa (espejo) | ‚úÖ S√≠ (paridad)    |
| Capacidad √∫til | ‚úÖ 100% capacidad  | ‚ùå 50% capacidad     | ‚ö†Ô∏è ~80% capacidad  |
| Seguridad      | ‚ùå Ninguna         | ‚úÖ Muy alta          | ‚úÖ Alta            |
| Ejemplo uso    | Edici√≥n video      | Datos cr√≠ticos       | Servidores grandes |

---

## üß© **Ejercicios resueltos en detalle:**

### ‚úÖ **1. Explicaci√≥n detallada niveles RAID 0, 1 y 5:**

- **RAID 0:** Divide datos en varios discos (sin redundancia).
- **RAID 1:** Duplicaci√≥n exacta en discos m√∫ltiples (m√°xima seguridad).
- **RAID 5:** Distribuye paridad en discos, equilibrio rendimiento/seguridad.

---

### ‚úÖ **2. Raz√≥n principal implementaci√≥n redundancia:**

- Proteger informaci√≥n frente a fallos inevitables del hardware.
- Mantener alta disponibilidad del sistema.

---

### ‚úÖ **3. Ventajas en rendimiento y fiabilidad detallada (RAID 1 y RAID 5):**

#### üî∏ **RAID 1:**
- **Fiabilidad:** Alta (espejo exacto).
- **Rendimiento:** Moderado en escritura (copia), alto en lectura (varios discos disponibles).

#### üî∏ **RAID 5:**
- **Fiabilidad:** Alta (permite recuperaci√≥n autom√°tica).
- **Rendimiento:** Alto en lectura (datos distribuidos), escritura moderada por c√°lculo paridad.

---

## üñ•Ô∏è **Ejemplos pr√°cticos detallados (RAID 1 y RAID 5):**

### RAID 1:
- Servidor bancario con datos financieros cr√≠ticos.
- Disco A falla ‚Üí Disco B mantiene copia exacta inmediata.

### RAID 5:
- Servidor web empresarial con bases de datos medianas.
- 4 discos de 1 TB ‚Üí 3 TB datos √∫tiles, 1 TB paridad distribuida.
- Un disco falla ‚Üí sistema sigue funcionando; al reemplazar disco, sistema reconstruye datos desde paridad.

---

## üé® **Gr√°fico resumen niveles RAID:**

```
                Rendimiento ‚Üë
Alta  | RAID 0
      |
      |                 RAID 5
      |                      ‚Ä¢ Equilibrio
Media |
      |            RAID 1
      |                      ‚Ä¢ Seguridad M√°xima
Baja  +-----------------------------------‚Üí Seguridad
     Baja             Media                Alta
```

---

## üìù **Conclusi√≥n clave sobre niveles RAID:**

- **RAID 0**: M√°ximo rendimiento sin seguridad.
- **RAID 1**: M√°xima seguridad con costo adicional.
- **RAID 5**: Balance entre rendimiento, capacidad y seguridad.

**Implementaci√≥n recomendada seg√∫n escenario:**
- **RAID 0:** Edici√≥n multimedia, aplicaciones r√°pidas sin datos cr√≠ticos.
- **RAID 1:** Informaci√≥n confidencial, alta disponibilidad.
- **RAID 5:** Bases de datos medianas/grandes, equilibrio √≥ptimo rendimiento y seguridad.



## 5. Arboles B Bplus


# üå≥ **Introducci√≥n a √Årboles B y B+**

Los **√°rboles B y B+** son estructuras de datos **auto-balanceadas**, utilizadas para mantener grandes vol√∫menes de datos ordenados y permitir b√∫squedas r√°pidas, inserciones eficientes y eliminaciones √°giles en bases de datos y sistemas de archivos.

---

## üìñ **Caracter√≠sticas fundamentales**

**√Årbol B:**
- Nodos almacenan claves y referencias directas a datos.
- Cada nodo tiene m√∫ltiples claves y m√∫ltiples punteros.
- Balanceado: garantiza la misma distancia a cualquier hoja desde la ra√≠z.

**√Årbol B+:**
- Variante del √Årbol B, pero **almacena todos los datos √∫nicamente en hojas**.
- Nodos internos almacenan √∫nicamente claves para direccionar b√∫squedas.
- Las hojas se enlazan en una lista, facilitando consultas secuenciales muy r√°pidas.

---

## üéØ **¬øPor qu√© √Årboles B y B+ son ideales para √≠ndices ordenados?**

### 1. üîπ **Acceso r√°pido y eficiente:**
- Su altura se mantiene siempre baja (balanceada).
- Esto asegura b√∫squedas eficientes en grandes vol√∫menes de datos: t√≠picamente `O(log n)`.

### 2. üîπ **Operaciones optimizadas:**
- Inserciones, b√∫squedas y eliminaciones r√°pidas sin necesidad de reorganizar toda la estructura.
- Excelente desempe√±o incluso con millones de registros.

### 3. üîπ **Rendimiento estable:**
- Acceso garantizado en pocas operaciones debido al balance constante.
- Ideal para bases de datos donde el rendimiento predecible es cr√≠tico.

### 4. üîπ **Soporte eficiente para rangos:**
- En √Årboles B+, las hojas enlazadas permiten consultas por rango (como fechas o n√∫meros consecutivos) extremadamente r√°pidas.

---

## üìä **Comparativa r√°pida √Årbol B vs. √Årbol B+:**

| Caracter√≠stica       | √Årbol B                  | √Årbol B+                      |
|----------------------|--------------------------|-------------------------------|
| Almacenamiento datos | Nodos internos y hojas   | Solo hojas                    |
| Uso ideal            | √çndices generales        | √çndices optimizados para rangos|
| Complejidad b√∫squedas| `O(log n)`               | `O(log n)`                    |
| Consultas rango      | Moderado                 | Excelente (hojas enlazadas)   |

---

## üå≤ **Ejemplo gr√°fico claro (√Årbol B+):**

```plaintext
                   [30, 60]
                 /     |      \
          [10, 20]  [40, 50]  [70, 80, 90]
              ‚ÜòÔ∏é         ‚ÜòÔ∏é         ‚ÜòÔ∏é
            datos      datos       datos
```

- **Ra√≠z:** Gu√≠a b√∫squedas r√°pidamente.
- **Hojas enlazadas:** Facilitan consultas secuenciales por rangos (10‚Üí20‚Üí40‚Üí50‚Üí70‚Üí80‚Üí90).

---

## üìö **Ejemplo pr√°ctico concreto:**

- Sup√≥n que buscas `50`:
  - Paso 1: Empieza en ra√≠z `[30, 60]`, 50 est√° entre 30 y 60, vas al nodo medio `[40, 50]`.
  - Paso 2: Encuentras `50` inmediatamente en este nodo hoja.

- B√∫squeda eficiente: Solo dos accesos incluso en grandes cantidades de datos.

---

## ‚úÖ **Razones detalladas para usar √Årboles B y B+ en √≠ndices ordenados:**

| Raz√≥n principal | Explicaci√≥n |
|-----------------|-------------|
| Altura Balanceada | Siempre m√≠nima altura (`O(log n)`), r√°pido acceso. |
| Menos accesos a disco | Menos operaciones f√≠sicas, m√°s eficiencia. |
| Inserci√≥n y eliminaci√≥n √°gil | Cambios locales m√≠nimos, no reorganizaci√≥n global. |
| √ìptimo para rangos | √Årbol B+ especialmente ideal por hojas enlazadas. |

---

## üé® **Gr√°fico resumen ventajas √Årbol B+ para √≠ndices ordenados:**

```plaintext
              Acceso a disco
Muchos  | Sin √≠ndice ordenado
        |
        | √Årbol B
        |       ‚Ä¢ eficiente general
Pocos   | √Årbol B+
        |       ‚Ä¢ excelente rango/orden
        +--------------------------------‚Üí Velocidad consulta por rango
           Baja                 Alta
```

---

## üìù **Conclusi√≥n clave sobre √Årboles B y B+:**

- **√Årbol B:** Indicado para √≠ndices generales equilibrados.
- **√Årbol B+:** M√°s usado en bases de datos modernas por su eficiencia adicional en consultas por rangos, gracias a hojas enlazadas y almacenamiento exclusivo de datos en hojas.

La estructura balanceada, velocidad de acceso garantizada y facilidad para realizar consultas secuenciales hacen de los √Årboles B y especialmente B+, la mejor elecci√≥n para implementar √≠ndices ordenados en bases de datos modernas.



## 6. Algoritmos Busqueda


# üîé **Introducci√≥n a Algoritmos de B√∫squeda**

Los algoritmos de b√∫squeda determinan c√≥mo se accede a los datos almacenados, siendo esenciales para el rendimiento de un Sistema Gestor de Bases de Datos (SGBD).

---

## ‚åõ **Costos Asint√≥ticos en Algoritmos**

La notaci√≥n asint√≥tica describe c√≥mo se comporta un algoritmo a medida que crece el volumen de datos (`n`).

- **O(1)**: Tiempo constante (independiente del tama√±o).
- **O(log n)**: Logar√≠tmico (muy eficiente, aumenta lentamente).
- **O(n)**: Lineal (tiempo crece proporcionalmente al tama√±o).

---

# üìö **An√°lisis de los Algoritmos Solicitados**

## üìç **(1) Programaci√≥n Din√°mica: (Evaluaci√≥n de √°rboles)**

### üî∏ (a) Sin optimizaci√≥n (evaluaci√≥n de √°rboles completos):

- **Tiempo:** Exponencial `O(2^n)` en √°rboles binarios.
- **Espacio:** `O(n)` por pila de llamadas recursivas.

**Raz√≥n:**  
Eval√∫a m√∫ltiples veces las mismas subexpresiones, resultando en redundancia y mucho tiempo de c√≥mputo.

### üî∏ (b) Con optimizaci√≥n (Memoizaci√≥n - Programaci√≥n Din√°mica):

- **Tiempo:** Polin√≥mico `O(n^2)` o mejor, dependiendo del problema.
- **Espacio:** `O(n^2)` por almacenamiento en tablas (generalmente matrices).

**Raz√≥n:**  
Almacenamiento intermedio evita c√°lculos repetidos (memoizaci√≥n), reduciendo enormemente el tiempo a cambio de memoria adicional.

---

## üìç **(2) Algoritmos de Selecci√≥n en SGBD (Condici√≥n Igualdad):**

### üî∏ **(a) B√∫squeda Lineal:**

- **Uso:** Tabla sin orden ni √≠ndice.
- **Costo:** `O(n)`
- Ejemplo:  
  Buscar cliente por nombre en tabla peque√±a sin √≠ndice.

---

### üî∏ **(b) B√∫squeda Binaria:**

- **Uso:** Tabla ordenada f√≠sicamente sin √≠ndice.
- **Costo:** `O(log n)`
- Ejemplo:  
  Buscar fecha espec√≠fica en historial de eventos ordenados.

---

### üî∏ **(c) √çndice Primario (clave):**

- **Uso:** √çndice sobre atributo clave primaria con estructura tipo hash.
- **Costo:** `O(1)` idealmente (acceso directo hash) o `O(log n)` si es √°rbol B+.
- Ejemplo:  
  Buscar usuario por ID √∫nico usando √≠ndice hash.

> Nota: El coste t√≠pico realista en √≠ndices primarios en bases de datos es generalmente **O(log n)** (√°rboles B+), aunque un √≠ndice hash idealizado ser√≠a **O(1)**.

---

### üî∏ **(d) √çndice Secundario (no clave):**

- **Uso:** √çndice sobre atributo no clave.
- **Costo:** Generalmente `O(log n)`.
- Ejemplo:  
  Buscar clientes por ciudad usando un √≠ndice secundario.

---

# üìâ **Gr√°fico comparativo claro:**

```plaintext
Eficiencia de b√∫squedas seg√∫n estructura:

Alto coste (lento)   Lineal ‚Üí O(n)
                          |
                          |
                          ‚Üì
                    Binaria ‚Üí O(log n)
                          |
                          ‚Üì
                    √çndice secundario ‚Üí O(log n)
                          |
                          ‚Üì
Bajo coste (r√°pido) √çndice primario ‚Üí O(1)/O(log n)
```

---

# üîç **Tema 7: Ejemplos hipot√©ticos (cuatro casos con diferentes costes):**

### üìå **Caso 1: Tabla peque√±a, sin √≠ndice**

```sql
SELECT * FROM Clientes WHERE Nombre = 'Laura';
```
- **Algoritmo:** Lineal.
- **Costo:** `O(n)`.

---

### üìå **Caso 2: Tabla ordenada f√≠sicamente por fecha**

```sql
SELECT * FROM Pedidos WHERE Fecha = '2024-03-24';
```
- **Algoritmo:** B√∫squeda Binaria.
- **Costo:** `O(log n)`.

---

### üìå **Caso 3: Tabla con √≠ndice primario (hash) por ID**

```sql
SELECT * FROM Usuarios WHERE ID = 12345;
```
- **Algoritmo:** √çndice primario (hash o √°rbol B+).
- **Costo:** `O(1)` (ideal hash), en la pr√°ctica `O(log n)` (√°rbol B+).

---

### üìå **Caso 4: Tabla con √≠ndice secundario (√°rbol B+)**

```sql
SELECT * FROM Productos WHERE Categor√≠a = 'Electr√≥nica';
```
- **Algoritmo:** √çndice secundario (√°rbol B+).
- **Costo:** `O(log n)` en √≠ndice, aunque luego recupera m√∫ltiples registros relacionados (coste adicional).

---

# ‚úÖ **Resumen gr√°fico pr√°ctico de casos hipot√©ticos:**

| Caso | Estructura tabla                 | √çndice         | Algoritmo usado | Costo te√≥rico |
|------|----------------------------------|----------------|-----------------|---------------|
| 1    | Peque√±a, no ordenada             | Ninguno        | Lineal          | `O(n)`        |
| 2    | Orden f√≠sico (fecha)             | Ninguno        | Binaria         | `O(log n)`    |
| 3    | Clave primaria con √≠ndice        | Primario (hash)| √çndice primario | `O(1)` ideal  |
| 4    | √çndice secundario por atributo   | Secundario B+  | √çndice secundario| `O(log n)`   |

---

## üìå **Conclusiones clave del tema Algoritmos de B√∫squeda:**

- La elecci√≥n del algoritmo depende de la estructura f√≠sica y l√≥gica del almacenamiento (tabla ordenada, existencia de √≠ndice).
- B√∫squedas lineales son lentas, pero simples; √≠ndices primarios son extremadamente r√°pidos.
- √çndices secundarios permiten b√∫squedas r√°pidas, aunque recuperan m√∫ltiples registros potencialmente.

---

## üéØ **Consejos pr√°cticos finales para mejorar rendimiento:**

- **Usar √≠ndices** siempre que las consultas sean frecuentes y relevantes.
- **Considerar el balance costo-beneficio** al agregar √≠ndices secundarios (ralentizan inserciones y actualizaciones, pero aceleran consultas).
- **Evaluar necesidades reales** para decidir usar hashing vs. √°rboles B+ (hash muy r√°pido para igualdad exacta, B+ para rangos o m√∫ltiples registros).



## 7. Procesamiento Consultas



# üóÉÔ∏è **Procesamiento de Consultas en SGBD**

El procesamiento de consultas se refiere a c√≥mo un Sistema Gestor de Bases de Datos interpreta, optimiza y ejecuta las consultas SQL recibidas por parte del usuario, transform√°ndolas en resultados concretos.

---

## üìå **Pasos L√≥gicos del Procesamiento de Consultas**

El procesamiento de consultas tiene tres fases clave:

### 1Ô∏è‚É£ **An√°lisis**
- Verifica la sintaxis y la sem√°ntica.
- Traduce la consulta a una forma intermedia (√°lgebra relacional).

### 2Ô∏è‚É£ **Optimizaci√≥n**
- Selecciona el mejor plan de ejecuci√≥n.
- Eval√∫a diferentes alternativas considerando √≠ndices, estad√≠sticas, costo de acceso a disco, y tiempos estimados.

### 3Ô∏è‚É£ **Evaluaci√≥n**
- Ejecuta el plan optimizado.
- Recupera datos usando estrategias como **materializaci√≥n** (guardar resultados intermedios) o **pipelining** (transferencia directa de resultados).

---

## üìê **Diagrama del Procesamiento de Consultas (completo y explicado)**

```
                  Consulta SQL
                       ‚îÇ
                       ‚ñº
             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
             ‚îÇ   An√°lisis        ‚îÇ
             ‚îÇ (Sintaxis y       ‚îÇ
             ‚îÇ  Traducci√≥n a     ‚îÇ
             ‚îÇ  √°lgebra rel.)    ‚îÇ
             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
             ‚îÇ   Optimizaci√≥n    ‚îÇ
             ‚îÇ  (Genera y elige  ‚îÇ
             ‚îÇ   mejor plan)     ‚îÇ
             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
             ‚îÇ    Evaluaci√≥n     ‚îÇ
             ‚îÇ(Ejecuta el plan   ‚îÇ
             ‚îÇoptimizado y       ‚îÇ
             ‚îÇobtiene resultados)‚îÇ
             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
                 Resultado final
```

---

## üìö **Traducci√≥n a √Ålgebra Relacional (Tema 4)**

### üîπ **Consulta original:**

```sql
SELECT e.LNAME 
FROM EMPLEADO e 
JOIN TRABAJA_EN te ON te.EMPLEADO = e.ID 
JOIN PROYECTO p ON p.ID = te.PROYECTO 
WHERE p.NOMBRE = 'AQUARIUS' AND e.FECHA_NAC >= '2000-01-01'
```

### üîπ **Traducci√≥n inicial (sin optimizar):**

```
œÄ_LNAME (
    œÉ_(NOMBRE='AQUARIUS' ‚àß FECHA_NAC ‚â• '2000-01-01') (
        EMPLEADO ‚®ù_(EMPLEADO.ID=TRABAJA_EN.EMPLEADO) TRABAJA_EN 
        ‚®ù_(TRABAJA_EN.PROYECTO=PROYECTO.ID) PROYECTO
    )
)
```

---

### üîπ **Optimizaci√≥n de la consulta (2 casos)**

**Caso 1: Empujar selecciones (optimizaci√≥n cl√°sica):**

```
œÄ_LNAME (
    (œÉ_FECHA_NAC ‚â• '2000-01-01'(EMPLEADO)) 
    ‚®ù TRABAJA_EN 
    ‚®ù (œÉ_NOMBRE='AQUARIUS'(PROYECTO))
)
```

- Reduce datos antes de realizar JOIN ‚Üí Mejora rendimiento notablemente.

**Caso 2: Cambiar orden de JOIN (optimizaci√≥n seg√∫n tama√±o tablas):**

```
œÄ_LNAME (
    (œÉ_NOMBRE='AQUARIUS'(PROYECTO) ‚®ù TRABAJA_EN) 
    ‚®ù œÉ_FECHA_NAC ‚â• '2000-01-01'(EMPLEADO)
)
```

- Empieza desde la tabla m√°s peque√±a (PROYECTO con filtro) para minimizar coste.

---

## üîó **Evaluaci√≥n consulta JOIN con Bucle Anidado por Bloques (Tema 8)**

### üîπ **Contexto del ejemplo pr√°ctico:**

- Consulta JOIN: `SELECT * FROM A JOIN B ON A.a = B.b`
- Tabla A: 20 bloques, Tabla B: 15 bloques, 10 bloques libres en memoria.

### üîπ **Algoritmo Bucle Anidado por Bloques (Block Nested Loop Join)**:

**F√≥rmula del coste (I/O):**
```
Coste = Bloques_A + (Bloques_A / (Bloques_memoria - 2)) * Bloques_B
```

- *(Bloques_memoria - 2)* porque uno se reserva para salida y otro para bloque actual.

### üîπ **C√°lculo detallado del coste:**

```
Bloques_A = 20, Bloques_B = 15, Bloques_memoria = 10

Coste = 20 + (20 / (10 - 2)) * 15
      = 20 + (20 / 8) * 15
      = 20 + 2.5 * 15
      = 20 + 37.5
      = 57.5 ‚âà 58 bloques de coste total
```

---

### üîπ **LRU vs. MRU (estrategia de reemplazo de bloques)**:

- **LRU (Least Recently Used):**
  - Descarta el bloque menos recientemente utilizado.
  - Generalmente eficiente (m√°s aciertos en cach√©).

- **MRU (Most Recently Used):**
  - Descarta el bloque m√°s recientemente utilizado.
  - √ötil si acceso repetitivo no frecuente; en este caso, generalmente menos eficiente.

---

## üìâ **Gr√°fico resumen claro sobre Procesamiento de Consultas:**

```
Consulta SQL ‚îÄ‚îÄ‚ñ∫ An√°lisis ‚îÄ‚îÄ‚ñ∫ Optimizaci√≥n ‚îÄ‚îÄ‚ñ∫ Evaluaci√≥n ‚îÄ‚îÄ‚ñ∫ Resultados

(An√°lisis)        (Optimizaci√≥n)                 (Evaluaci√≥n)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ      ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ              ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚Ä¢ Sintaxis       ‚Ä¢ Elegir mejor plan           ‚Ä¢ Materializaci√≥n
‚Ä¢ Sem√°ntica      ‚Ä¢ Orden JOINs                 ‚Ä¢ Pipelining
‚Ä¢ √Ålgebra        ‚Ä¢ √çndices disponibles         ‚Ä¢ Acceso a disco
```

---

## üìå **Ejemplo hipot√©tico visual claro:**

- Consulta: 
```sql
SELECT Nombre FROM Estudiantes WHERE Edad >= 20
```

**Fases:**
- An√°lisis: Sintaxis OK ‚Üí √Ålgebra: œÉ_Edad‚â•20(Estudiantes)
- Optimizaci√≥n: √çndice sobre Edad disponible ‚Üí usa √≠ndice.
- Evaluaci√≥n: Recupera r√°pidamente datos por √≠ndice ‚Üí entrega resultados.

---

## ‚úÖ **Conclusi√≥n clave sobre Procesamiento de Consultas:**

- **An√°lisis:** Traducci√≥n precisa y sintaxis correcta son clave.
- **Optimizaci√≥n:** Crucial para eficiencia, especialmente en JOINs complejos.
- **Evaluaci√≥n:** Depende de estrategias eficientes (materializaci√≥n vs pipelining).

Una buena optimizaci√≥n puede cambiar radicalmente el rendimiento de consultas, especialmente en grandes bases de datos.



## 8. Modelado Multidimensional


# üìä **Introducci√≥n al Modelado Multidimensional**

El **Modelado Multidimensional** es una t√©cnica usada en sistemas de an√°lisis de datos (OLAP) para representar grandes vol√∫menes de informaci√≥n desde diferentes perspectivas (dimensiones), facilitando an√°lisis efectivos y toma de decisiones.

---

## üìå **Conceptos Clave:**

### üîπ **Tablas de Dimensiones:**
- Representan **caracter√≠sticas o atributos** de los datos.
- Permiten "cortar" y filtrar los datos desde diferentes √°ngulos.

**Ejemplos:**
- **Clientes:** Nombre, ciudad, pa√≠s.
- **Productos:** Categor√≠a, marca, modelo.
- **Tiempo:** D√≠a, mes, a√±o.

---

### üîπ **Tablas de Hechos:**
- Contienen los **datos medibles**, generalmente num√©ricos.
- Vinculan las dimensiones con m√©tricas espec√≠ficas.

**Ejemplos:**
- **Ventas:** Cantidad vendida, ingresos generados.
- **Compras:** Total de compras, costos asociados.

---

### üîπ **Medidas:**
- Son los valores num√©ricos espec√≠ficos dentro de tablas de hechos.
- Indican lo que realmente se est√° analizando.

**Ejemplos:**
- Cantidad de productos vendidos.
- Ventas totales en d√≥lares.
- Cantidad de clientes nuevos por d√≠a.

---

## üìê **Ejemplo Gr√°fico de un Esquema Estrella:**

```
           DIMENSI√ìN CLIENTES
                   ‚îÇ
                   ‚îÇ
DIMENSI√ìN TIEMPO‚îÄ‚îÄ‚îÄ‚òÖ‚îÄ‚îÄ‚îÄ‚îÄDIMENSI√ìN PRODUCTOS
                   ‚îÇ
                   ‚îÇ
           TABLA DE HECHOS (VENTAS)
                   ‚îÇ
            (Medidas: Ventas, ingresos)
```

---

# üîç **Diferencias entre OLTP y OLAP**

### üîπ **OLTP (Online Transaction Processing):**
- Maneja **transacciones frecuentes** y operacionales.
- Transacciones r√°pidas, peque√±as y concurrentes.
- Ejemplos claros:  
  - Ventas en l√≠nea (Amazon).  
  - Sistemas bancarios (transferencias).

### üîπ **OLAP (Online Analytical Processing):**
- Orientado al **an√°lisis y toma de decisiones**.
- Consultas complejas sobre grandes vol√∫menes de datos.
- Ejemplos claros:  
  - An√°lisis de ventas por regi√≥n.  
  - Reportes financieros y planificaci√≥n estrat√©gica.

---

### üìà **Comparativa r√°pida OLTP vs. OLAP:**

| Aspecto           | OLTP                             | OLAP                            |
|-------------------|----------------------------------|---------------------------------|
| Uso               | Operaciones frecuentes           | An√°lisis y decisiones           |
| Transacciones     | Muchas, r√°pidas, peque√±as        | Menos frecuentes, muy grandes   |
| Consultas         | Simples, precisas                | Complejas, agregadas            |
| Dise√±o Modelo     | Normalizado                      | Multidimensional, desnormalizado|
| Ejemplo real      | Pagos online                     | Business Intelligence (BI)      |

---

## üé≤ **Esquema Estrella vs. Cubos OLAP**

### üîπ **Esquema Estrella:**
- Es un modelo de dise√±o f√≠sico para **bases de datos relacionales** que facilita consultas r√°pidas.
- Consiste en una tabla central de hechos y m√∫ltiples tablas de dimensiones alrededor.
- Sencillo, eficiente en rendimiento de consultas r√°pidas.

### üîπ **Cubos OLAP:**
- Representaci√≥n l√≥gica **multidimensional**.
- Permite an√°lisis interactivo ("slice & dice"), "drill-down" (detalle) y "roll-up" (agregado).
- No necesariamente f√≠sico, generalmente l√≥gico o conceptual.

---

### üìå **Consideraciones principales:**

| Aspecto        | Esquema Estrella                  | Cubos OLAP                          |
|----------------|-----------------------------------|-------------------------------------|
| Naturaleza     | F√≠sica (tablas reales)            | L√≥gica o conceptual (visualizaci√≥n) |
| Almacenamiento | Bases de datos relacionales       | Sistemas OLAP                       |
| Uso            | Consultas r√°pidas SQL             | An√°lisis interactivos, din√°micos    |
| Complejidad    | Baja                              | Alta (permite interacci√≥n din√°mica) |

---

## üéØ **Ejemplos pr√°cticos del Modelo Multidimensional**

### üîπ **Tabla de Dimensi√≥n (Clientes):**
| ID_Cliente | Nombre    | Ciudad    | Pa√≠s      |
|------------|-----------|-----------|-----------|
| 001        | Juan      | Madrid    | Espa√±a    |
| 002        | Laura     | Asunci√≥n  | Paraguay  |

### üîπ **Tabla de Dimensi√≥n (Productos):**
| ID_Producto | Nombre       | Categor√≠a   |
|-------------|--------------|-------------|
| P001        | iPhone 15    | Smartphones |
| P002        | Lenovo Yoga  | Laptop      |

### üîπ **Tabla de Hechos (Ventas):**
| ID_Cliente | ID_Producto | Fecha      | Cantidad | Ingresos |
|------------|-------------|------------|----------|----------|
| 001        | P001        | 2024-03-23 | 2        | $2000    |
| 002        | P002        | 2024-03-24 | 1        | $1200    |

---

## üìâ **Gr√°fico resumen OLTP vs. OLAP:**

```
                Transacciones
Muchas ‚îÇ OLTP
       ‚îÇ   ‚Ä¢ sistemas operativos
       ‚îÇ   ‚Ä¢ bancos, ventas online
       ‚îÇ
       ‚îÇ
Pocas  ‚îÇ            OLAP
       ‚îÇ               ‚Ä¢ an√°lisis profundo
       ‚îÇ               ‚Ä¢ BI, planificaci√≥n
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Complejidad Consultas
        Baja                 Alta
```

---

## üß© **Ejercicios resueltos claramente:**

### ‚úÖ **(1) Tablas de Dimensiones, Hechos y Medidas:**
- **Dimensiones:** Atributos anal√≠ticos (Clientes, Productos, Tiempo).
- **Hechos:** Datos medibles (Ventas, ingresos).
- **Medidas:** Valores num√©ricos espec√≠ficos (Cantidad vendida, dinero generado).

---

### ‚úÖ **(2) Diferencia entre OLTP y OLAP (t√©rminos propios con ejemplos):**
- **OLTP:** R√°pido, peque√±as operaciones frecuentes (Ej: Amazon, pagos).
- **OLAP:** An√°lisis, grandes operaciones complejas (Ej: Data Warehouse financiero).

---

### ‚úÖ **(3) Diferencia entre esquema estrella y cubos OLAP:**
- **Esquema estrella:** F√≠sico, r√°pido para consultas espec√≠ficas SQL.
- **Cubos OLAP:** L√≥gico, din√°mico para an√°lisis interactivo y multidimensional.

---

## üîë **Conclusiones claves sobre Modelado Multidimensional:**
- Esencial para **Business Intelligence** (BI).
- Tablas de dimensi√≥n dan contexto; hechos proporcionan mediciones num√©ricas.
- OLTP es operativo y r√°pido; OLAP anal√≠tico y profundo.
- Esquema estrella facilita rapidez f√≠sica; cubos OLAP permiten an√°lisis interactivo l√≥gico.



## 9. Transacciones ACID


# üîê **Introducci√≥n a Transacciones (SGBD)**

Una **transacci√≥n** en un Sistema Gestor de Bases de Datos (SGBD) es una unidad l√≥gica que agrupa operaciones que se ejecutan de manera indivisible, asegurando que todas las operaciones dentro se completen correctamente o ninguna lo haga, garantizando la consistencia del sistema.

**Ejemplo sencillo:**  
Transferir dinero de la cuenta A a la cuenta B es una sola transacci√≥n que incluye:

1. Restar dinero en cuenta A
2. Sumar dinero en cuenta B

Ambas deben completarse exitosamente o ninguna debe ejecutarse.

---

## üîÑ **Fases del Ciclo de Vida de una Transacci√≥n**

Una transacci√≥n atraviesa claramente 5 fases:

### 1Ô∏è‚É£ **Inicio (Begin)**
- La transacci√≥n comienza formalmente.

### 2Ô∏è‚É£ **Ejecuci√≥n (Execution)**
- Realiza las operaciones (INSERT, UPDATE, DELETE, SELECT).

### 3Ô∏è‚É£ **Validaci√≥n (Validation)**
- Verifica si las operaciones pueden completarse (restricciones, bloqueos).

### 4Ô∏è‚É£ **Confirmaci√≥n (Commit)**
- Guarda permanentemente cambios realizados en la base de datos.

### 5Ô∏è‚É£ **Cancelaci√≥n (Rollback, si aplica)**
- Si algo falla, revierte todas las operaciones realizadas hasta el momento del fallo, volviendo al estado inicial.

---

## üìå **Propiedades ACID**

Estas propiedades garantizan la confiabilidad en un entorno transaccional:

| Propiedad    | Definici√≥n breve |
|--------------|------------------|
| **Atomicidad**    | Todo o nada. La transacci√≥n ocurre completamente o no ocurre. |
| **Consistencia**  | La base de datos pasa de un estado v√°lido a otro estado v√°lido. |
| **Aislamiento**   | Cada transacci√≥n se ejecuta independientemente sin interferir con otras transacciones simult√°neas. |
| **Durabilidad**   | Cambios confirmados permanecen permanentes aun ante fallos del sistema.|

---

## üìö **Explicaci√≥n detallada Propiedades ACID (est√°ndar SQL)**

### üîπ **Atomicidad (Atomicity):**
- Operaciones dentro de la transacci√≥n son indivisibles.
- **Ejemplo:**  
  Si falla un paso de la transferencia bancaria, ambas cuentas permanecen intactas.

### üîπ **Consistencia (Consistency):**
- La base de datos siempre permanece en un estado v√°lido antes y despu√©s de la transacci√≥n.
- **Ejemplo:**  
  No permitir saldo negativo tras transferencia bancaria.

### üîπ **Aislamiento (Isolation):**
- Transacciones concurrentes no interfieren entre s√≠.
- **Ejemplo:**  
  Dos transferencias simult√°neas no causan inconsistencias en los saldos.

### üîπ **Durabilidad (Durability):**
- Los cambios realizados son permanentes una vez confirmados (commit).
- **Ejemplo:**  
  Tras una transferencia exitosa, el saldo se mantiene actualizado incluso si ocurre un corte de energ√≠a.

---

## üìà **Gr√°fico claro del Ciclo de Vida de una Transacci√≥n:**

```
           Transacci√≥n iniciada
                  ‚îÇ
                  ‚ñº
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ  Ejecuci√≥n  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ
                  ‚îÇ                ‚îÇ
                  ‚ñº                ‚ñº
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ Validaci√≥n  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÇ Cancelaci√≥n ‚îÇ (Rollback)
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚ñº
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇConfirmaci√≥n ‚îÇ (Commit)
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚ñº
             Cambios permanentes
```

---

## üß© **Ejercicios Resueltos en detalle:**

### ‚úÖ **(a) Definici√≥n concreta de transacci√≥n:**

- Es un conjunto l√≥gico indivisible de operaciones en bases de datos.
- Todas se ejecutan exitosamente o todas fallan, asegurando integridad.

---

### ‚úÖ **(b) Ciclo de vida detallado:**

- **Inicio:** Comienzo formal.
- **Ejecuci√≥n:** Realizaci√≥n de operaciones.
- **Validaci√≥n:** Chequeo restricciones y bloqueos.
- **Commit:** Confirmaci√≥n final.
- **Rollback:** Anulaci√≥n de operaciones si algo falla.

---

### ‚úÖ **(c) Propiedades ACID definidas claramente:**

- **Atomicidad:** Todo o nada.
- **Consistencia:** Estado v√°lido siempre.
- **Aislamiento:** Independencia entre transacciones simult√°neas.
- **Durabilidad:** Permanencia de los cambios tras confirmaci√≥n.

---

## üîë **Ejemplo pr√°ctico completo con propiedades ACID:**

### üîπ **Caso pr√°ctico: Transferencia Bancaria (Transacci√≥n T)**

- Estado inicial:
  - Cuenta A: 500 USD
  - Cuenta B: 300 USD

- Operaciones de la transacci√≥n:
  1. Cuenta A ‚Üí -100 USD  
  2. Cuenta B ‚Üí +100 USD  

- Estado final (esperado si Commit):
  - Cuenta A: 400 USD
  - Cuenta B: 400 USD

### üîπ **Validaci√≥n de propiedades ACID:**

| Propiedad     | Explicaci√≥n en ejemplo bancario |
|---------------|---------------------------------|
| Atomicidad    | Ambas cuentas cambian juntas o ninguna cambia.|
| Consistencia  | Saldos siempre coherentes, no negativos.|
| Aislamiento   | Otra transacci√≥n simult√°nea no afecta esta operaci√≥n.|
| Durabilidad   | Una vez completada, transferencias permanecen a√∫n con fallos del sistema.|

---

## üìâ **Gr√°fico resumen propiedades ACID:**

```
         Estado inicial v√°lido
                  ‚îÇ
Atomicidad        ‚îÇ Transacci√≥n ‚îÄ‚îÄ‚îÄ‚îÄ (Si falla) ‚îÄ‚îÄ‚îÄ‚ñ∫ Estado inicial
                  ‚ñº
Consistencia ‚îÄ‚îÄ Estado v√°lido intermedio
                  ‚îÇ
Aislamiento       ‚îÇ (Sin interferencia externa)
                  ‚ñº
Durabilidad ‚îÄ‚îÄ Estado final v√°lido y permanente tras commit
```

---

## üéØ **Conclusi√≥n clave del tema Transacciones y ACID:**

- Las **transacciones** garantizan integridad y coherencia.
- Las propiedades **ACID** (Atomicidad, Consistencia, Aislamiento y Durabilidad) son esenciales para mantener la fiabilidad del sistema.
- Sin estas propiedades, los datos ser√≠an vulnerables a inconsistencia y corrupci√≥n.

Una implementaci√≥n adecuada del modelo ACID es cr√≠tica para aplicaciones empresariales, bancarias y cualquier sistema que maneje datos sensibles.



## 10. Concurrencia


# üîÑ **Introducci√≥n a la Concurrencia**

La **concurrencia** en bases de datos permite que m√∫ltiples usuarios o aplicaciones interact√∫en simult√°neamente con la base de datos, lo que genera eficiencia pero puede producir conflictos si no se gestiona correctamente.

---

## üìå **(a) Funci√≥n del Componente de Gesti√≥n de Concurrencia en un SGBD**

El **Gestor de Concurrencia** asegura que las transacciones simult√°neas no interfieran negativamente entre s√≠, manteniendo la integridad y consistencia de los datos.  

**Funciones principales:**
- Controlar accesos simult√°neos.
- Evitar conflictos en escrituras/lecturas simult√°neas.
- Asegurar aislamiento entre transacciones.

---

## üìê **(b) Estructura de Datos para Gesti√≥n y Concesi√≥n de Bloqueos**

El sistema utiliza una estructura llamada **Tabla de Bloqueos**:

| Recurso (Dato) | Estado Bloqueo | Transacci√≥n(es) que bloquean | Cola de Espera |
|----------------|----------------|-------------------------------|----------------|
| Registro A     | Exclusivo (X)  | T1                            | T2, T3         |
| Registro B     | Compartido (S) | T2, T4                        | T5             |

- **Bloqueo Exclusivo (X):** Para escrituras (una sola transacci√≥n).
- **Bloqueo Compartido (S):** Para lecturas simult√°neas (m√∫ltiples transacciones).

---

## üîí **(a) Protocolo de Bloqueo de 2 Fases (2PL - Two Phase Locking)**

Garantiza la **serializabilidad**, asegurando una ejecuci√≥n concurrente equivalente a una secuencial.

### üîπ **Fases del Protocolo 2PL:**
- **Fase 1 (Creciente):** Adquiere bloqueos necesarios; no libera ninguno.
- **Fase 2 (Decreciente):** Libera bloqueos; no adquiere nuevos bloqueos.

**Ejemplo gr√°fico:**
```
Tiempo ‚ñ∫
T1: ‚îÇ‚îÄ‚îÄ‚îÄ Adquiere Bloqueos ‚îÄ‚îÄ‚îÄ‚îÇ‚îÄ‚îÄ Libera Bloqueos ‚îÄ‚îÄ‚îÇ
    ‚ñ≤                        ‚ñ≤
Fase creciente          Fase decreciente
```

---

## üìë **(b) Variantes del Protocolo 2PL**

- **2PL B√°sico:** Adquiere y libera bloqueos en dos fases estrictas.
- **2PL Estricto (Strict 2PL):** Libera bloqueos exclusivos (X) √∫nicamente al terminar (Commit/Rollback).
- **2PL Riguroso (Rigorous 2PL):** Libera todos los bloqueos (S/X) s√≥lo al finalizar (m√°s restrictivo, m√°s seguro).

---

## üìñ **Tema 5: Conceptos de Control de Concurrencia**

### üîπ **Planificaci√≥n (Schedule):**
- Orden espec√≠fico en que operaciones de m√∫ltiples transacciones se ejecutan simult√°neamente.

**Ejemplo:**
```
T1: Leer(A), Escribir(A)
T2: Leer(A), Escribir(A)
```

Una planificaci√≥n posible:
```
Leer(A)T1 ‚Üí Leer(A)T2 ‚Üí Escribir(A)T1 ‚Üí Escribir(A)T2
```

---

### üîπ **Planificaci√≥n Secuencial (Serial Schedule):**
- Las transacciones se ejecutan estrictamente una tras otra, sin simultaneidad.

**Ejemplo:**
```
(T1 completa) ‚Üí (T2 completa) ‚Üí (T3 completa)
```

---

### üîπ **Planificaci√≥n Secuenciable (Serializable Schedule):**
- Ejecuci√≥n concurrente equivalente l√≥gicamente a alguna planificaci√≥n secuencial.

**Ejemplo:**
```
Leer(A)T1 ‚Üí Escribir(A)T1 ‚Üí Leer(B)T2 ‚Üí Escribir(B)T2
```

Aunque hay concurrencia, la planificaci√≥n es equivalente a T1‚ÜíT2 o T2‚ÜíT1.

---

### üîπ **Secuencialidad en Cuanto a Conflicto (Conflict Serializability):**
- Las operaciones conflictivas (lectura/escritura sobre el mismo recurso) siguen un orden estricto como en una planificaci√≥n secuencial.

---

### üîπ **Secuencialidad en Cuanto a Vistas (View Serializability):**
- Equivalencia l√≥gica en t√©rminos de valores le√≠dos y escritos, aunque el orden de operaciones pueda diferir levemente.

---

## üìà **Importancia de la Secuencialidad (Serializabilidad)**

La serializabilidad es cr√≠tica porque asegura la **consistencia y correcci√≥n** de la base de datos en ambientes concurrentes. Si las planificaciones no son serializables, pueden generarse inconsistencias en los datos.

---

## üß© **Ejercicios resueltos concretamente:**

### ‚úÖ **(a) Funci√≥n de Gesti√≥n Concurrencia en SGBD:**
- Garantiza que m√∫ltiples usuarios trabajen simult√°neamente sin conflictos.

---

### ‚úÖ **(b) Estructura de datos para bloqueos:**
- **Tabla de bloqueos:** Registra recursos, bloqueos actuales y solicitudes en espera.

---

### ‚úÖ **(a) Protocolo de 2 fases (2PL):**
- Dos fases claramente separadas: adquisici√≥n (creciente) y liberaci√≥n (decreciente).

---

### ‚úÖ **(b) Variantes protocolo 2PL:**
- **2PL b√°sico, Estricto (strict) y Riguroso (rigorous)**.

---

### ‚úÖ **Explicaci√≥n conceptos control concurrencia claramente:**

| Concepto                  | Explicaci√≥n simple                       |
|---------------------------|------------------------------------------|
| Planificaci√≥n             | Orden ejecuci√≥n operaciones.             |
| Planificaci√≥n secuencial  | Transacciones una tras otra (sin concurrencia). |
| Planificaci√≥n secuenciable| Concurrencia, pero equivalente a secuencial.|
| Secuencialidad conflicto  | Operaciones conflictivas ordenadas estrictamente.|
| Secuencialidad vistas     | Equivalencia l√≥gica en resultados obtenidos.|

---

## üìå **Gr√°fico claro resumen conceptos concurrencia:**

```
Planificaci√≥n
     ‚îÇ
     ‚îú‚îÄ‚îÄ Secuencial ‚îÄ‚îÄ‚îÄ‚îÄ Una tras otra (segura, sin conflictos)
     ‚îÇ
     ‚îî‚îÄ‚îÄ Secuenciable ‚îÄ‚îÄ Concurrente, pero equivalente a secuencial
                  ‚îÇ
                  ‚îú‚îÄ‚îÄ Conflicto ‚îÄ‚îÄ Operaciones conflictivas respetan orden
                  ‚îÇ
                  ‚îî‚îÄ‚îÄ Vistas ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Equivalente en resultados le√≠dos/escritos
```

---

## üìö **Ejemplo gr√°fico concreto protocolo 2PL:**

- **Transacci√≥n bancaria T1 (transferencia dinero)**:
  1. Bloquea cuenta A (X)
  2. Bloquea cuenta B (X)
  3. Actualiza saldos
  4. Libera bloqueos (X)

- **Protocolo estricto (Strict 2PL)**:
  - Libera bloqueos solo al terminar la transacci√≥n completamente (commit).

```
Tiempo ‚ñ∫
T1 ‚îÇ‚îÄ Bloquear A ‚îÄ Bloquear B ‚îÄ‚îÄ Actualizar ‚îÄ‚îÄ Commit & Liberar ‚îÄ‚îÇ
```

---

## üéØ **Conclusi√≥n clave sobre Concurrencia en SGBD:**

- Controlar concurrencia es vital para asegurar integridad.
- El protocolo 2PL asegura serializabilidad (orden l√≥gico seguro).
- La planificaci√≥n secuenciable garantiza que concurrencia sea tan segura como la ejecuci√≥n secuencial estricta.

Un buen control de concurrencia evita p√©rdida de datos, conflictos y mantiene la coherencia en bases de datos cr√≠ticas.



## 11. Protocolos Distribuidos


# üåê **Introducci√≥n a Protocolos Distribuidos en SGBD**

Los **protocolos distribuidos** gestionan la **coordinaci√≥n y concurrencia** en sistemas donde los datos est√°n repartidos en m√∫ltiples sitios geogr√°ficamente distribuidos. Aseguran consistencia y disponibilidad.

---

# üó≥Ô∏è **(a) Protocolo de Control de Concurrencia por Quorum de Consenso**

Este protocolo garantiza coherencia distribuida usando **pesos** asignados a cada sitio.

### üîπ **Conceptos b√°sicos:**
- Cada sitio recibe un peso asignado.
- Para realizar **lectura o escritura**, la transacci√≥n debe sumar un **quorum m√≠nimo** de pesos.
- Generalmente, se asignan pesos seg√∫n la importancia o disponibilidad de sitios.

---

## üìå **(b) Implicancias para definir valores de Quorum:**

- **Mayor quorum de lectura:**  
  Mayor consistencia, menor velocidad.
- **Mayor quorum de escritura:**  
  Mayor costo, mayor seguridad en escrituras.
- La suma de quorum de lectura (Q_L) y quorum de escritura (Q_E) debe ser mayor al total de pesos asignados para asegurar consistencia:
  
  ```
  Q_L + Q_E > Peso_Total
  ```

---

## üìö **(c) Valores para protocolos espec√≠ficos:**

### üîπ **Protocolo de Mayor√≠a (Majority Protocol):**
- **Condici√≥n:** Quorum lectura + Quorum escritura > total de pesos.
- **Ejemplo claro:** Si total = 10,  
  - Lectura ‚â• 6 y Escritura ‚â• 5 (o viceversa).  
  (Ej.: Q_L=6, Q_E=5; 6+5=11>10).

### üîπ **Protocolo Sesgado (Biased Protocol):**
- Un sitio especial tiene peso dominante (sesgado).
- **Ejemplo claro:** Si total = 10  
  - Sitio principal tiene peso=7; dem√°s sitios peso=1.  
  - Quorum lectura y escritura puede satisfacerse con sitio sesgado solo (Ej.: Q_L=7, Q_E=7).

---

# ‚úÖ **(a) Protocolo de Commit en 2 Fases (2PC - Two Phase Commit)**

Permite coordinar confirmaci√≥n de transacciones distribuidas asegurando consistencia.

### üîπ **Fases del protocolo 2PC:**

- **Fase 1 (Preparaci√≥n):**
  1. **Coordinador** env√≠a `PREPARE` a todos los participantes.
  2. **Participantes** ejecutan operaciones localmente y responden:
     - `READY` (preparado) o
     - `ABORT` (cancelar).

- **Fase 2 (Confirmaci√≥n):**
  - Si TODOS los participantes respondieron `READY`, coordinador env√≠a `COMMIT` para confirmar cambios.
  - Si UNO responde `ABORT`, env√≠a `ABORT` a todos para revertir cambios.

---

## üìå **Ejemplo gr√°fico Protocolo 2PC:**

```
         Coordinador
             ‚îÇ
Fase 1:      ‚îÇ PREPARE?
             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Participante 1
             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Participante 2
             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Participante 3
             ‚îÇ
             ‚îÇ READY ‚óÑ‚îÄ‚îÄ‚îÄ Participante 1
             ‚îÇ READY ‚óÑ‚îÄ‚îÄ‚îÄ Participante 2
             ‚îÇ READY ‚óÑ‚îÄ‚îÄ‚îÄ Participante 3
             ‚îÇ
Fase 2:      ‚îÇ COMMIT
             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Participantes (Confirmaci√≥n)
```

---

# üöß **(b) Qu√© pasa si falla el Coordinador en 2PC?**

- Los participantes quedan "bloqueados" temporalmente sin instrucciones claras (estado incertidumbre).
- Deben esperar recuperaci√≥n del coordinador o usar t√©cnicas alternativas (backup, tiempo de espera, etc.).

---

# üö® **(c) Qu√© pasa si un Participante falla en 2PC?**

- Si falla en fase preparaci√≥n: Coordinador env√≠a `ABORT` al resto.
- Si falla despu√©s de `READY` (en confirmaci√≥n): 
  - Al recuperarse, debe consultar al coordinador para saber si debe COMMIT o ABORT (consulta estado).

---

## üìä **Gr√°fico claro resumen fallos protocolo 2PC:**

```
Coordinador         Participantes
    ‚îÇ                    ‚îÇ
    ‚ñº                    ‚ñº
Falla:                Falla:
- Incertidumbre       - Antes READY: ABORT
participantes.        - Tras READY: Recuperaci√≥n consultando coordinador.
```

---

## üß© **Ejercicios resueltos claramente:**

### ‚úÖ **(a) Quorum Consenso explicado claramente:**
- Controla concurrencia mediante quorum m√≠nimo (pesos de sitios) para lecturas/escrituras.

---

### ‚úÖ **(b) Implicancias definir valores quorum:**
- Mayor quorum lectura ‚Üí m√°s consistencia, menor rendimiento.
- Mayor quorum escritura ‚Üí seguridad escrituras, menor eficiencia.
- Condici√≥n clave: Q_L + Q_E > peso total.

---

### ‚úÖ **(c) Valores quorum Mayor√≠a y Sesgado ejemplos concretos:**
- **Mayor√≠a:** (total=10): Q_L=6, Q_E=5 (6+5>10)
- **Sesgado:** sitio principal con peso dominante (peso=7; quorum=7).

---

### ‚úÖ **(a) Pasos protocolo Commit 2 Fases (2PC):**
- **Preparaci√≥n:** PREPARE ‚Üí participantes READY/ABORT
- **Confirmaci√≥n:** COMMIT si todos READY; si no, ABORT.

---

### ‚úÖ **(b) Falla coordinador (qu√© hacen participantes?):**
- Estado incertidumbre (bloqueados). Esperan recuperaci√≥n o consulta externa.

---

### ‚úÖ **(c) Falla participante (qu√© hace sitio?):**
- Antes READY: Coordinador aborta operaci√≥n.
- Despu√©s READY: Participante recuperado consulta coordinador para resolver su estado (commit/abort).

---

## üîë **Conclusi√≥n clave sobre Protocolos Distribuidos:**

- **Quorum de Consenso** garantiza concurrencia segura, sacrificando parcialmente velocidad por seguridad.
- **Protocolo Commit 2 Fases (2PC)** asegura consistencia distribuida mediante confirmaci√≥n en fases, con riesgos claros si ocurre fallo coordinador o participante.

---

## üéØ **Resumen Gr√°fico Claro Protocolos Distribuidos:**

```
Protocolos Distribuidos ‚îÄ‚îÄ‚îÄ‚ñ∫ Coordinaci√≥n y Concurrencia Segura
          ‚îÇ
          ‚îú‚îÄ‚îÄ Quorum Consenso ‚îÄ‚îÄ‚îÄ‚ñ∫ Lectura/escritura por quorum
          ‚îÇ        ‚îú‚îÄ Mayor√≠a (lect+escr>total)
          ‚îÇ        ‚îî‚îÄ Sesgado (sitio dominante)
          ‚îÇ
          ‚îî‚îÄ‚îÄ Commit 2 Fases ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Confirmaci√≥n distribuida en fases
                   ‚îú‚îÄ Fase preparaci√≥n
                   ‚îî‚îÄ Fase confirmaci√≥n
```



## 12. Almacenamiento Distribuido


# üåê **Introducci√≥n al Almacenamiento Distribuido**

El **Almacenamiento Distribuido** se refiere a la forma en que los datos de una base de datos se almacenan y gestionan f√≠sicamente en m√∫ltiples sitios distribuidos, garantizando disponibilidad, rendimiento y seguridad.

---

## üìå **Formas Principales de Almacenamiento Distribuido**

Existen principalmente dos formas:

### üîπ **1. Replicaci√≥n**
- Consiste en tener **copias exactas** de los mismos datos en diferentes sitios distribuidos.

**Ventajas:**
- Alta disponibilidad y fiabilidad.
- R√°pido acceso local a datos comunes.

**Desventajas:**
- Costos mayores por almacenamiento redundante.
- Dificultad en mantener sincronizaci√≥n constante.

**Ejemplo claro:**
- Datos de usuarios replicados en sitios distribuidos globalmente para acceso r√°pido local.

---

### üîπ **2. Fragmentaci√≥n**
Dividir los datos en partes m√°s peque√±as (**fragmentos**) almacenadas en diferentes sitios. Existen dos tipos:

#### (a) **Fragmentaci√≥n Horizontal**
- Divide filas de una tabla.
- Cada fragmento contiene un conjunto espec√≠fico de filas completas.

**Ejemplo:**
| Sitio   | Fragmento                           |
|---------|-------------------------------------|
| Europa  | Clientes europeos                   |
| Am√©rica | Clientes norteamericanos y latinos  |

#### (b) **Fragmentaci√≥n Vertical**
- Divide columnas de una tabla.
- Cada fragmento almacena un subconjunto de columnas en sitios diferentes.

**Ejemplo:**
| Sitio       | Fragmento                    |
|-------------|------------------------------|
| Finanzas    | Columnas (Salario, Cuentas)  |
| RRHH        | Columnas (Nombre, Direcci√≥n) |

**Ventajas fragmentaci√≥n:**
- Mejor rendimiento seg√∫n necesidades locales.
- Menor cantidad de datos transmitidos en consultas espec√≠ficas.

**Desventajas fragmentaci√≥n:**
- Mayor complejidad de gesti√≥n.
- Consultas globales pueden ser lentas.

---

## üì° **Estrategia de Semireuni√≥n (Semijoin)**

Es una estrategia que minimiza la transmisi√≥n de datos en consultas distribuidas tipo JOIN. Env√≠a solo atributos necesarios para identificar filas relevantes.

### üîπ **Pasos Semireuni√≥n (si consulta recibida en sitio 1):**
- Consulta: `SELECT * FROM R JOIN S` (sitio 1 tiene tabla R, sitio 2 tabla S)

1. **Sitio 1** env√≠a columna clave (join) de R al sitio 2.
2. **Sitio 2** calcula JOIN parcial usando claves recibidas.
3. **Sitio 2** devuelve al sitio 1 solo filas necesarias para completar JOIN final.
4. **Sitio 1** realiza JOIN final.

---

## üìä **C√°lculo detallado del coste transmisi√≥n Semijoin**

Sup√≥n:
- Sitio 1: tabla R, 500 filas, claves 4 bytes.
- Sitio 2: tabla S, 1000 filas, 100 bytes/fila.

### üîπ **C√°lculo costes si consulta llega a sitio 1:**

| Paso | Acci√≥n                                  | Coste transmisi√≥n aproximado |
|------|-----------------------------------------|------------------------------|
| 1    | S1 env√≠a claves R ‚Üí S2 (500 √ó 4 bytes)  | **2000 bytes** (~2KB)        |
| 2    | S2 responde filas relevantes (200 filas √ó 100 bytes)| **20000 bytes** (~20KB)|
|      | **Costo total aprox.:**                 | **22KB**                     |

---

### üîπ **Si consulta llega a sitio 2 (invertido):**

| Paso | Acci√≥n                                  | Coste transmisi√≥n aproximado |
|------|-----------------------------------------|------------------------------|
| 1    | S2 env√≠a claves S ‚Üí S1 (1000 √ó 4 bytes) | **4000 bytes** (~4KB)        |
| 2    | S1 responde filas relevantes (300 filas √ó 80 bytes)| **24000 bytes** (~24KB) |
|      | **Costo total aprox.:**                 | **28KB**                     |

---

## üìà **Comparativa gr√°fica Replicaci√≥n vs. Fragmentaci√≥n**

```
                        Replicaci√≥n
               Alta ‚îÇ  ‚Ä¢ disponibilidad m√°xima
Disponibilidad     ‚îÇ  ‚Ä¢ alto coste almacenamiento
                   ‚îÇ
                   ‚îÇ                 Fragmentaci√≥n
                   ‚îÇ              ‚Ä¢ menos almacenamiento
               Baja‚îÇ              ‚Ä¢ m√°s rendimiento local
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Rendimiento local
                  Bajo                  Alto
```

---

## üß© **Ejercicios resueltos claramente:**

### ‚úÖ **(1) Formas almacenamiento distribuido explicadas claramente:**
- **Replicaci√≥n:** Copias exactas en m√∫ltiples sitios (alta disponibilidad).
- **Fragmentaci√≥n:** Divisi√≥n horizontal o vertical seg√∫n necesidad (rendimiento optimizado).

---

### ‚úÖ **(2) Pasos claros y coste Semireuni√≥n:**

**Ejemplo concreto (Consulta llega sitio 1):**

1. **Sitio 1 ‚Üí claves R ‚Üí Sitio 2**
2. **Sitio 2 ‚Üí filas relevantes ‚Üí Sitio 1**
3. **Sitio 1 completa JOIN**

**Coste aprox.:** ~22KB (menor que enviar tablas completas)

---

## üìå **Caso pr√°ctico espec√≠fico Semireuni√≥n:**

- Consulta original: 
```sql
SELECT * FROM Clientes JOIN Compras ON Clientes.id = Compras.cliente_id
```

### üîπ **Datos ejemplo:**
- Clientes (Sitio 1): 1000 filas, claves=4 bytes
- Compras (Sitio 2): 3000 filas, 50 bytes/fila

### üîπ **Pasos Semijoin (consulta en Sitio 1):**
1. Sitio 1 env√≠a claves Clientes (4KB aprox.) ‚Üí Sitio 2.
2. Sitio 2 devuelve filas coincidentes (ej: 500 filas √ó 50 bytes = 25KB aprox.) ‚Üí Sitio 1.

### üîπ **Coste total claro:** 
- Aproximadamente 29KB transmisi√≥n (mucho menor que enviar toda tabla Compras ‚âà 150KB).

---

## üîë **Conclusiones clave Almacenamiento Distribuido:**

- **Replicaci√≥n**: Alta disponibilidad y redundancia, costo mayor.
- **Fragmentaci√≥n**: Optimiza rendimiento, menor almacenamiento, mayor complejidad.
- Estrategia de **Semireuni√≥n** reduce significativamente costo transmisi√≥n en JOINs distribuidos.

---

## üéØ **Gr√°fico resumen claro formas almacenamiento distribuido:**

```
Almacenamiento Distribuido
        ‚îÇ
        ‚îú‚îÄ‚îÄ Replicaci√≥n ‚îÄ‚îÄ‚ñ∫ Alta disponibilidad
        ‚îÇ       ‚îî‚îÄ Copias exactas m√∫ltiples sitios
        ‚îÇ
        ‚îî‚îÄ‚îÄ Fragmentaci√≥n ‚îÄ‚îÄ‚ñ∫ Optimizaci√≥n rendimiento
                ‚îú‚îÄ Horizontal (filas)
                ‚îî‚îÄ Vertical (columnas)
```


## 13. Optimizacion Consultas


# üöÄ **Introducci√≥n a la Optimizaci√≥n de Consultas**

La **Optimizaci√≥n de Consultas** es el proceso que usa un SGBD para transformar una consulta SQL escrita por el usuario en una versi√≥n m√°s eficiente en t√©rminos de rendimiento.

---

## üìê **√Ålgebra Relacional para Optimizaci√≥n**

El SGBD transforma consultas SQL en **√Ålgebra Relacional**, que permite usar reglas matem√°ticas para elegir el orden m√°s eficiente de las operaciones.

### üîπ **Operaciones b√°sicas √°lgebra relacional:**

- **œÉ (Selecci√≥n):** Filtra filas.
- **œÄ (Proyecci√≥n):** Filtra columnas.
- **‚®ù (Join):** Combina tablas.
- **√ó (Producto cartesiano):** Combina cada fila de una tabla con cada fila de otra.

---

## üìö **Tema 4: Traducci√≥n inicial y optimizaci√≥n JOIN**

### üîπ **Consulta original:**
```sql
SELECT e.LNAME 
FROM EMPLEADO e 
JOIN TRABAJA_EN te ON te.EMPLEADO = e.ID 
JOIN PROYECTO p ON p.ID = te.PROYECTO 
WHERE p.NOMBRE = 'AQUARIUS' AND e.FECHA_NAC >= '2000-01-01'
```

### üîπ **Traducci√≥n inicial (sin optimizar):**
```
œÄ_LNAME(
    œÉ_(NOMBRE='AQUARIUS' ‚àß FECHA_NAC‚â•'2000-01-01') (
        EMPLEADO ‚®ù_(EMPLEADO.ID=te.EMPLEADO) TRABAJA_EN te
                 ‚®ù_(te.PROYECTO=p.ID) PROYECTO p
    )
)
```

---

### üß© **Optimizaci√≥n (2 casos pr√°cticos):**

#### **Caso 1: Empujar selecciones (Push selection)**

- Aplica primero selecciones para reducir el tama√±o de tablas antes de JOIN.

```
œÄ_LNAME(
    (œÉ_FECHA_NAC‚â•'2000-01-01'(EMPLEADO))
    ‚®ù_(ID=EMPLEADO) TRABAJA_EN
    ‚®ù_(PROYECTO=ID) (œÉ_NOMBRE='AQUARIUS'(PROYECTO))
)
```

- **Ventaja:** Menos datos al hacer JOINs, rendimiento notablemente mejorado.

---

#### **Caso 2: Cambiar orden JOIN seg√∫n tama√±o tablas (Join reordering)**

- Ordena JOINs comenzando por tablas peque√±as para reducir el coste.

```
œÄ_LNAME(
    (œÉ_NOMBRE='AQUARIUS'(PROYECTO) ‚®ù TRABAJA_EN)
    ‚®ù œÉ_FECHA_NAC‚â•'2000-01-01'(EMPLEADO)
)
```

- **Ventaja:** Reduce significativamente filas antes del JOIN final con tabla grande (EMPLEADO).

---

## üìå **Tema 7: Consultas hipot√©ticas SELECT y sus costes**

### üîπ **Consulta original hipot√©tica:**
```sql
SELECT * FROM Clientes WHERE Pais = 'Paraguay';
```

#### **Caso 1: Tabla peque√±a, sin √≠ndices**
- **Algoritmo:** B√∫squeda lineal.
- **Costo:** O(n) ‚Üí alto.
- **Ejemplo:** Tabla Clientes (500 filas).

---

#### **Caso 2: Tabla ordenada f√≠sicamente**
- **Algoritmo:** B√∫squeda binaria.
- **Costo:** O(log n) ‚Üí medio.
- **Ejemplo:** Tabla Clientes ordenada por pa√≠s.

---

#### **Caso 3: √çndice secundario sobre pa√≠s**
- **Algoritmo:** √çndice secundario (B+).
- **Costo:** O(log n) ‚Üí bajo.
- **Ejemplo:** √çndice sobre columna Pais.

---

#### **Caso 4: Tabla replicada localmente**
- **Algoritmo:** Acceso local inmediato.
- **Costo:** O(1) ‚Üí muy bajo.
- **Ejemplo:** Copia local en servidor Paraguay.

---

## üìâ **Gr√°fico claro comparativo coste consultas:**

```
Costo consulta (SELECT WHERE)

Alto ‚îÇ Lineal (sin √≠ndices)
     ‚îÇ
     ‚îÇ        Binaria (tabla ordenada)
     ‚îÇ
     ‚îÇ                 √çndice secundario (B+)
Bajo ‚îÇ                           Replicaci√≥n local
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Eficiencia
```

---

## üìö **Resumen pr√°ctico optimizaci√≥n consultas**

| T√©cnica optimizaci√≥n | Descripci√≥n clara             | Ventaja principal           |
|----------------------|-------------------------------|-----------------------------|
| Empujar selecciones  | Aplicar filtros antes JOINs   | Menos filas en JOIN         |
| Reordenar JOINs      | Tablas peque√±as primero       | Menor coste JOINs grandes   |
| √çndices secundarios  | Uso columnas frecuentes       | B√∫squeda r√°pida O(log n)    |
| Replicaci√≥n local    | Copias locales tablas comunes | Acceso inmediato O(1)       |

---

## ‚úÖ **Ejercicios resueltos claramente:**

### **(Tema 4)** √Ålgebra relacional y optimizaciones claras:

- **Consulta original ‚Üí √Ålgebra relacional claramente explicada**
- **Optimizaci√≥n 1:** Empujar selecciones.
- **Optimizaci√≥n 2:** Cambiar orden JOIN.

---

### **(Tema 7)** Casos hipot√©ticos claramente definidos y explicados:

| Caso | Descripci√≥n                           | Algoritmo usado       | Costo te√≥rico |
|------|---------------------------------------|-----------------------|---------------|
| 1    | Sin √≠ndices                           | Lineal                | O(n) alto     |
| 2    | Tabla ordenada f√≠sicamente            | Binaria               | O(log n) medio|
| 3    | √çndice secundario disponible          | √çndice secundario (B+)| O(log n) bajo |
| 4    | Replicaci√≥n local                     | Acceso local          | O(1) muy bajo |

---

## üéØ **Conclusi√≥n clave sobre Optimizaci√≥n de Consultas:**

- Usar √°lgebra relacional permite al SGBD reestructurar consultas para optimizar rendimiento.
- La selecci√≥n temprana (push selection) y la reordenaci√≥n de JOINs son las t√©cnicas m√°s efectivas.
- √çndices secundarios y replicaci√≥n local proporcionan grandes mejoras en b√∫squedas espec√≠ficas.

---

## üìä **Gr√°fico resumen claro sobre Optimizaci√≥n Consultas:**

```
Optimizaci√≥n Consultas SQL ‚îÄ‚îÄ‚ñ∫ Mejor rendimiento
           ‚îÇ
           ‚îú‚îÄ √Ålgebra Relacional ‚îÄ‚îÄ‚ñ∫ reglas equivalentes
           ‚îÇ
           ‚îú‚îÄ Empujar Selecciones ‚îÄ‚îÄ‚ñ∫ menos filas JOIN
           ‚îÇ
           ‚îú‚îÄ Reordenar JOINs ‚îÄ‚îÄ‚ñ∫ menor coste global
           ‚îÇ
           ‚îî‚îÄ Uso √çndices y Replicaci√≥n ‚îÄ‚îÄ‚ñ∫ acceso r√°pido (log n o 1)
```



## 14. Normalizacion Dependencias Funcionales

# üìö **Introducci√≥n a la Normalizaci√≥n**

La **normalizaci√≥n** es un proceso en dise√±o de bases de datos que organiza los datos eficientemente para:

- Eliminar redundancias.
- Evitar anomal√≠as (inserci√≥n, actualizaci√≥n, eliminaci√≥n).
- Garantizar integridad y consistencia.

---

## üìå **Dependencias Funcionales**

Una **Dependencia Funcional (DF)** ocurre cuando el valor de un atributo (o conjunto de atributos) determina √∫nicamente el valor de otro atributo.

Notaci√≥n clara:  
```
A ‚Üí B ("A determina B")
```

---

# üß© **Ejercicio pr√°ctico claro (Empleado)**

Tabla inicial:  
```
Empleado (CI, Nombre, Direcci√≥n, Cargo, Cod_Dep)
```

### üîπ **Dependencias Funcionales (DF) iniciales:**

- `CI ‚Üí Nombre, Direcci√≥n, Cargo, Cod_Dep`
  - Cada persona (CI) tiene un nombre, direcci√≥n, cargo y departamento √∫nicos.
- `Cod_Dep ‚Üí Cargo (en algunos casos)`
  - Posible dependencia parcial si el cargo depende directamente del departamento.

---

## üìê **Aplicaci√≥n de las Formas Normales (Empleado)**

### üîπ **Primera Forma Normal (1FN):**

- No atributos multivaluados. Tabla ya cumple (cada atributo es at√≥mico).

**Estado:**  
```
Empleado(CI, Nombre, Direcci√≥n, Cargo, Cod_Dep)
```

---

### üîπ **Segunda Forma Normal (2FN):**

- No dependencias parciales respecto a la clave primaria.

En este caso, la clave primaria es `CI`, que es un atributo simple, por lo que ya cumple 2FN directamente (no hay dependencias parciales posibles).

**Estado 2FN:**  
```
Empleado(CI, Nombre, Direcci√≥n, Cargo, Cod_Dep)
```

---

### üîπ **Tercera Forma Normal (3FN):**

- No dependencias transitivas (atributos no clave que dependen de otro atributo no clave).

**Analizar dependencia transitiva:**  
- Supongamos posible dependencia transitiva: `Cod_Dep ‚Üí Cargo`.
- Para evitar esta dependencia, separar atributos en dos tablas:

**Resultado claro en 3FN:**  
```
Empleado(CI, Nombre, Direcci√≥n, Cod_Dep)
Departamento(Cod_Dep, Cargo)
```

---

## üîë **Claves Primarias y For√°neas claramente definidas:**

- **Empleado:**
  - Clave primaria: `CI`
  - Clave for√°nea: `Cod_Dep` ‚Üí referencia a `Departamento(Cod_Dep)`

- **Departamento:**
  - Clave primaria: `Cod_Dep`

---

# üìö **Ejercicio pr√°ctico claro (Carrera, Materia, Docente)**

Tablas iniciales claramente definidas:

```
Carrera(CodCarrera, NombreCarrera)
Materia(CodMateria, NombreMateria, CodCarrera)
Docente(CI_Docente, NombreDocente, CodMateria)
```

### üîπ **Dependencias Funcionales identificadas claramente:**

- **Carrera:** `CodCarrera ‚Üí NombreCarrera`
- **Materia:** `CodMateria ‚Üí NombreMateria, CodCarrera`
- **Docente:** `CI_Docente ‚Üí NombreDocente, CodMateria`

---

## üìå **Aplicar Normalizaci√≥n claramente explicada:**

### üîπ **1FN (Cumple desde inicio)**

Cada atributo at√≥mico claramente definido.

### üîπ **2FN (Cumple desde inicio)**

Cada tabla tiene una clave primaria simple. No existen dependencias parciales posibles.

### üîπ **3FN (Dependencias transitivas a verificar)**

- No se detectan dependencias transitivas claras en estas tablas originales. 
- Ya cumplen claramente 3FN.

**Resultado final claro (en 3FN):**  
```
Carrera(CodCarrera, NombreCarrera)
Materia(CodMateria, NombreMateria, CodCarrera)
Docente(CI_Docente, NombreDocente, CodMateria)
```

---

## üìë **Claves Primarias y For√°neas claramente definidas:**

| Tabla        | Clave primaria | Claves for√°neas                       |
|--------------|----------------|---------------------------------------|
| Carrera      | CodCarrera     | ‚Äî                                     |
| Materia      | CodMateria     | CodCarrera ‚Üí Carrera(CodCarrera)      |
| Docente      | CI_Docente     | CodMateria ‚Üí Materia(CodMateria)      |

---

## üìä **Gr√°fico resumen claro Normalizaci√≥n 1FN ‚Üí 3FN:**

```
Tabla inicial (1FN) ‚îÄ‚îÄ‚ñ∫ (2FN: Sin dependencias parciales)
           ‚îÇ
           ‚ñº
(3FN: Sin dependencias transitivas)
           ‚îÇ
           ‚ñº
Tablas separadas claras (3FN, eficiente)
```

---

## üéØ **Ejemplo visual claro Normalizaci√≥n Empleado (3FN):**

**ANTES (tabla √∫nica con redundancia):**
| CI   | Nombre  | Direcci√≥n | Cargo      | Cod_Dep |
|------|---------|-----------|------------|---------|
| 123  | Juan    | Calle A   | Analista   | D01     |
| 456  | Laura   | Calle B   | Analista   | D01     |

- Redundancia clara en "Cargo" (Analista repetido).

**DESPU√âS (en 3FN):**

**Empleado**
| CI   | Nombre  | Direcci√≥n | Cod_Dep |
|------|---------|-----------|---------|
| 123  | Juan    | Calle A   | D01     |
| 456  | Laura   | Calle B   | D01     |

**Departamento**
| Cod_Dep | Cargo    |
|---------|----------|
| D01     | Analista |

- Redundancia eliminada claramente.

---

## ‚úÖ **Conclusi√≥n clave sobre Normalizaci√≥n y Dependencias Funcionales:**

- La normalizaci√≥n elimina claramente redundancias y evita anomal√≠as.
- La clave es identificar claramente dependencias funcionales, parciales y transitivas.
- Aplicar formas normales (1FN, 2FN, 3FN) resulta en un dise√±o m√°s limpio, eficiente y robusto.

---

## üìù **Resumen gr√°fico claro Normalizaci√≥n y Dependencias Funcionales:**

```
Normalizaci√≥n y Dependencias Funcionales ‚îÄ‚îÄ‚ñ∫ Eficiencia dise√±o BD
              ‚îÇ
              ‚îú‚îÄ DF claras ‚îÄ‚îÄ‚ñ∫ Atributos determinantes
              ‚îÇ
              ‚îú‚îÄ 1FN (at√≥micos) ‚îÄ‚îÄ‚ñ∫ Sin atributos multivaluados
              ‚îÇ
              ‚îú‚îÄ 2FN (parciales) ‚îÄ‚îÄ‚ñ∫ Dependencia completa clave primaria
              ‚îÇ
              ‚îî‚îÄ 3FN (transitivas) ‚îÄ‚îÄ‚ñ∫ No dependencias transitivas
```



## 15. Modelado ER SQL


# üìê **1. Modelo ER: Empresa-Empleados-Departamento**

## üîπ **Modelo Entidad-Relaci√≥n (MER):**

**Entidades:**
- **Empleado:** CI (PK), Nombre, Direcci√≥n, Cargo
- **Departamento:** Cod_Dep (PK), Nombre_Dep

**Relaciones:**
- **Trabaja_en:** Relaci√≥n N:1 (muchos empleados en un departamento).

**Diagrama ER claro:**
```
Empleado (CI, Nombre, Direcci√≥n, Cargo)
     ‚îÇN
     ‚îÇ
[Trabaja_en]
     ‚îÇ1
     ‚ñº
Departamento (Cod_Dep, Nombre_Dep)
```

---

## üîπ **Transformaci√≥n al Modelo Relacional:**

```
Empleado(CI, Nombre, Direcci√≥n, Cargo, Cod_Dep(FK))
Departamento(Cod_Dep, Nombre_Dep)
```

- **PK (primaria):** Empleado(CI), Departamento(Cod_Dep)
- **FK (for√°nea):** Empleado(Cod_Dep ‚Üí Departamento)

---

# üìö **2. Modelo ER: Universidad (Carreras, Materias, Docentes, Alumnos)**

## üîπ **Modelo ER claro:**

**Entidades:**
- **Carrera:** CodCarrera (PK), Nombre
- **Materia:** CodMateria (PK), Nombre, CodCarrera(FK)
- **Docente:** CI_Docente (PK), Nombre
- **Alumno:** CI_Alumno (PK), Nombre

**Relaciones:**
- **Dicta:** Docente 1:N Materia
- **Inscripci√≥n:** Alumno N:M Materia (Tabla intermedia)
- **Carrera-Materia:** Carrera 1:N Materia

**Diagrama ER claro:**
```
Carrera (CodCarrera, Nombre)
  ‚îÇ1
  ‚îÇ
[Tiene]
  ‚îÇN
  ‚ñº
Materia (CodMateria, Nombre)
  ‚îÇN           N
  ‚îÇ            ‚îÇ
[Dicta]     [Inscripci√≥n]
  ‚îÇ1           ‚îÇ
Docente(CI,Nombre) Alumno(CI,Nombre)
```

---

## üîπ **Modelo Relacional claro:**

```
Carrera(CodCarrera, Nombre)
Materia(CodMateria, Nombre, CodCarrera(FK))
Docente(CI_Docente, Nombre)
Alumno(CI_Alumno, Nombre)
Inscripci√≥n(CI_Alumno(FK), CodMateria(FK), Nota)
Dicta(CI_Docente(FK), CodMateria(FK))
```

---

## üîë **Consultas SQL (Universidad):**

- **Materias por carrera espec√≠fica:**
```sql
SELECT M.Nombre
FROM Materia M
WHERE M.CodCarrera = 'INF';
```

- **Docentes que dictan materia espec√≠fica:**
```sql
SELECT D.Nombre
FROM Docente D
JOIN Dicta DT ON D.CI_Docente = DT.CI_Docente
WHERE DT.CodMateria = 'BD2';
```

- **Alumnos que rindieron ex√°menes en m√°s de una materia:**
```sql
SELECT A.Nombre, COUNT(*) AS MateriasExamen
FROM Alumno A
JOIN Inscripci√≥n I ON A.CI_Alumno = I.CI_Alumno
GROUP BY A.Nombre
HAVING COUNT(*) > 1;
```

---

# üìñ **3. Modelo ER: Biblioteca (Libro, Autor, Editorial, Socio, Pr√©stamo)**

## üîπ **Modelo ER claro:**

**Entidades:**
- **Libro:** CodLibro (PK), Titulo, CodEditorial(FK)
- **Autor:** CodAutor (PK), Nombre
- **Editorial:** CodEditorial (PK), Nombre
- **Socio:** CodSocio (PK), Nombre, Direcci√≥n
- **Pr√©stamo:** CodPrestamo (PK), Fecha, CodLibro(FK), CodSocio(FK)

**Relaciones:**
- **Libro-Autor:** N:M (tabla intermedia "LibroAutor")
- **Libro-Editorial:** N:1
- **Pr√©stamo-Socio-Libro:** N:1 (cada pr√©stamo para un libro espec√≠fico a un socio)

**Modelo relacional final claro:**
```
Libro(CodLibro, Titulo, CodEditorial(FK))
Autor(CodAutor, Nombre)
Editorial(CodEditorial, Nombre)
Socio(CodSocio, Nombre, Direcci√≥n)
Prestamo(CodPrestamo, Fecha, CodLibro(FK), CodSocio(FK))
LibroAutor(CodLibro(FK), CodAutor(FK))
```

---

# üìä **Consultas SQL y √Ålgebra relacional claras (Empresa-Empleado-Departamento)**

- **Lista empleados por departamento (SQL):**
```sql
SELECT E.Nombre, D.Nombre_Dep
FROM Empleado E
JOIN Departamento D ON E.Cod_Dep = D.Cod_Dep;
```

- **√Ålgebra relacional:**
```
œÄ_(Nombre,Nombre_Dep)(Empleado ‚®ù_(Cod_Dep) Departamento)
```

- **Nombre empleados con cargo 'Analista' (SQL):**
```sql
SELECT Nombre
FROM Empleado
WHERE Cargo = 'Analista';
```

- **√Ålgebra relacional:**
```
œÄ_Nombre(œÉ_Cargo='Analista'(Empleado))
```

- **Total empleados por departamento (SQL):**
```sql
SELECT Cod_Dep, COUNT(*) AS TotalEmpleados
FROM Empleado
GROUP BY Cod_Dep;
```

---

# üìå **Consultas SQL (Universidad):**

- **Listar materias por carrera:**
```sql
SELECT Nombre
FROM Materia
WHERE CodCarrera = 'INF';
```

- **Buscar docentes por materia espec√≠fica:**
```sql
SELECT D.Nombre
FROM Docente D
JOIN Dicta DT ON D.CI_Docente = DT.CI_Docente
WHERE DT.CodMateria = 'BD2';
```

- **Mostrar alumnos que rindieron ex√°menes en m√°s de una materia:**
```sql
SELECT A.Nombre, COUNT(I.CodMateria) AS MateriasExamen
FROM Alumno A
JOIN Inscripci√≥n I ON A.CI_Alumno = I.CI_Alumno
GROUP BY A.Nombre
HAVING COUNT(I.CodMateria) > 1;
```

---

# ‚úÖ **Conclusiones clave (MER y SQL):**

- **Modelo ER** permite representar claramente entidades, relaciones y cardinalidades.
- **Transformaci√≥n relacional** traduce ER en tablas espec√≠ficas (PKs/FKs).
- Las **consultas SQL** permiten extracci√≥n precisa de informaci√≥n espec√≠fica seg√∫n necesidad.
- **√Ålgebra relacional** facilita la optimizaci√≥n visual de consultas antes de ejecuci√≥n en SGBD.

---

## üéØ **Gr√°fico resumen claro MER ‚Üí Relacional ‚Üí SQL:**

```
Requerimiento ‚îÄ‚îÄ‚ñ∫ Modelo ER
       ‚îÇ
       ‚ñº
Modelo Relacional (tablas, PK/FK)
       ‚îÇ
       ‚ñº
Consultas SQL claras y eficientes
       ‚îÇ
       ‚ñº
Resultados r√°pidos y exactos
```

